--
-- Copyright 2016, NICTA
--
-- This software may be distributed and modified according to the terms of
-- the GNU General Public License version 2. Note that NO WARRANTY is provided.
-- See "LICENSE_GPLv2.txt" for details.
--
-- @TAG(NICTA_GPL)
--

include "bilbyfs.cogent"
include <gum/allocpool.cogent>
include <gum/list.cogent>
include <gum/common.cogent>
include "ubi.cogent"
include "index.cogent"
include "fsm.cogent"
include "wbuf.cogent"
include "serial.cogent"

ostore_init: (ExState, MountState!, OstoreState take (..)) -> R (ExState, OstoreState take ubi_vol) (ErrCode, ExState, OstoreState take (..))
ostore_init (ex, mount_st, ostore_st) =
  let next_inum = bilbyFsRootIno
  and next_sqnum:U64 = 0
  and wbuf_eb = bilbyFsFirstLogEbNum
  and used:U32 = 0
  and sync_offs:U32 = 0
  and leb_size = wubi_vol_usable_leb_size mount_st.vol
  -- rbuf
  in buf_create(ex, leb_size)
  | Error ex ->
    Error (eNoMem, ex, ostore_st)
  | Success (ex, rbuf) ->
    -- wbuf
    buf_create(ex, leb_size)
    | Error ex ->
      let ex = buf_free(ex, rbuf)
      in Error (eNoMem, ex, ostore_st)
    | Success (ex, wbuf) ->
      -- opad
      newObj ex
      | Error ex ->
        let ex = buf_free(ex, rbuf)
        and ex = buf_free(ex, wbuf)
        in Error (eNoMem, ex, ostore_st)
      | Success (ex, opad) ->
        -- idxpool
        allocpool_create[RbtIndexNode] ex
        | Error ex ->
          let ex = buf_free(ex, rbuf)
          and ex = buf_free(ex, wbuf)
          and ex = freeObj(ex, opad)
          in Error (eNoMem, ex, ostore_st)
        | Success (ex, idxpool) ->
          -- gimpool
          allocpool_create[RbtGimNode] ex
          | Error ex ->
            let ex = buf_free(ex, rbuf)
            and ex = buf_free(ex, wbuf)
            and ex = freeObj(ex, opad)
            and ex = allocpool_free[RbtIndexNode] (ex, idxpool)
            in Error (eNoMem, ex, ostore_st)
          | Success (ex, gimpool) ->
            newFsmState ex
            | Error ex ->
              let ex = buf_free(ex, rbuf)
              and ex = buf_free(ex, wbuf)
              and ex = freeObj(ex, opad)
              and ex = allocpool_free[RbtIndexNode] (ex, idxpool)
              and ex = allocpool_free[RbtGimNode] (ex, gimpool)
              in Error (eNoMem, ex, ostore_st)
            | Success (ex, fsm_st) ->
              rbt_create[ObjId, ObjAddr] ex
              | Error ex ->
                let ex = buf_free(ex, rbuf)
                and ex = buf_free(ex, wbuf)
                and ex = freeObj(ex, opad)
                and ex = allocpool_free[RbtIndexNode] (ex, idxpool)
                and ex = allocpool_free[RbtGimNode] (ex, gimpool)
                and ex = freeFsmState(ex, fsm_st)
                in Error (eNoMem, ex, ostore_st)
              | Success (ex, addrs) ->
                let (ex, r) = fsm_init(ex, mount_st, fsm_st) !mount_st
                in r
                | Error (err, fsm_st) ->
                  let ex = buf_free(ex, rbuf)
                  and ex = buf_free(ex, wbuf)
                  and ex = freeObj(ex, opad)
                  and ex = allocpool_free[RbtIndexNode] (ex, idxpool)
                  and ex = allocpool_free[RbtGimNode] (ex, gimpool)
                  and ex = freeFsmState(ex, fsm_st)
                  and ex = rbt_free[ObjId, ObjAddr](ex, addrs)
                  in Error (err, ex, ostore_st)
                | Success fsm_st ->
                  let max_nb_sum_entry = leb_size / (bilbyFsObjHeaderSize + 8)
                  and max_nb_sum_entry = if mount_st.no_summary then 1 else max_nb_sum_entry
                  and _ = _cogent_debug "max_nb_sum_entry = "
                  and _ = _cogent_debug_u32 max_nb_sum_entry
                  and _ = _cogent_debug ", sum_size = "
                  and _ = _cogent_debug_u32 (serialise_size_ObjSummary max_nb_sum_entry)
                  and _ = _cogent_debug "\n"
                  in summary_init (ex, max_nb_sum_entry) -- minimum Obj size is ObjHeader + id
                  | Error ex ->
                    let ex = buf_free(ex, rbuf)
                    and ex = buf_free(ex, wbuf)
                    and ex = freeObj(ex, opad)
                    and ex = allocpool_free[RbtIndexNode] (ex, idxpool)
                    and ex = allocpool_free[RbtGimNode] (ex, gimpool)
                    and ex = fsm_clean(ex, fsm_st)
                    and ex = rbt_free[ObjId, ObjAddr](ex, addrs)
                    in Error (eNoMem, ex, ostore_st)
                  | Success (ex, summary, sum_obj) ->
                    let oaddr = mkObjAddr
                    and pools = #{idx=idxpool,gim=gimpool}
                    and opad = obj_init_default(opad, bilbyFsObjTypePad)
                    and opad = opad {ounion=TObjPad ()}
                    and index_st = #{addrs}
                    and ostore_st = ostore_st {next_inum, next_sqnum, rbuf,
                       wbuf_eb, wbuf, used, sync_offs, opad,
                       pools, oaddr, fsm_st, index_st, summary, sum_obj}
                    in Success (ex, ostore_st)

ostore_read_sum_f: #{acc:(ExState, Buffer, BufOffs), obsv:(U32, U32, UbiVol!), idx:U32} -> LRR (ExState, Buffer, BufOffs) ErrCode
ostore_read_sum_f #{acc=(ex, rbuf, offs), obsv=(ebnum, io_size, ubi_vol), idx} =
  let ((ex, rbuf), r) = wubi_leb_read #{ex, ubi_vol, ebnum, buf=rbuf, buf_offs=offs, nb_bytes=io_size}
  in r
  | Error e -> ((ex, rbuf, offs + io_size), Break e)
  | Success () ->
    ((ex, rbuf, offs + io_size), Iterate ())


ostore_read_sum_extra_pages: (ExState, MountState!, OstoreState, U32, U32) -> RR (ExState, OstoreState) () ErrCode
ostore_read_sum_extra_pages (ex, mount_st, ostore_st {rbuf}, ebnum, sum_offs) =
-- we know that the last page was loaded by ostore_read_sum
  let io_size = mount_st.super.io_size
  and offs = mount_st.super.eb_size - io_size
  in if sum_offs > mount_st.super.eb_size || sum_offs < io_size then
    _cogent_debug "ostore_read_sum_extra_pages: invalid sum_offs=" ;
    _cogent_debug_u32 sum_offs ;
    _cogent_debug "\n" ;
    ((ex, ostore_st {rbuf}), Error eInval)
  else if sum_offs < offs then
    let offs = sum_offs - (sum_offs % io_size)
    and nb_pages = ((mount_st.super.eb_size - offs) / io_size) - 1
    and _ = _cogent_debug "ostore_read_sum_extra_pages: nb_pages = "
    and _ = _cogent_debug_u32 nb_pages
    and _ = _cogent_debug "\n"
    and ((ex, rbuf, _), r) =
          seq32[(ExState, Buffer, BufOffs), (U32,U32,UbiVol), ErrCode]
            #{frm=0, to=nb_pages, step=1, f=ostore_read_sum_f,
              acc=(ex, rbuf, offs), obsv=(ebnum, io_size, ostore_st.ubi_vol)} !ostore_st
    in r
    | Break e ->
      ((ex, ostore_st {rbuf}), Error e)
    | Iterate () ->
      ((ex, ostore_st {rbuf}), Success ())
  else
    ((ex, ostore_st {rbuf}), Success ())

ostore_read_sum: (ExState, MountState!, OstoreState, U32) -> RR (ExState, OstoreState) U32 ErrCode
ostore_read_sum(ex, mount_st, ostore_st {rbuf}, ebnum) =
  let offs = mount_st.super.eb_size - mount_st.super.io_size
  and io_size = mount_st.super.io_size
  and ((ex, rbuf), r) = wubi_leb_read #{ex, ubi_vol=ostore_st.ubi_vol, ebnum, buf=rbuf, buf_offs=offs, nb_bytes=io_size} !ostore_st
  in r
  | Error e ->
    ((ex, ostore_st {rbuf}), Error e)
  | Success () ->
    let sum_offs = deserialise_le32(rbuf, mount_st.super.eb_size - 4) !rbuf
    and _ = _cogent_debug "Reading summary, sum_offset = "
    and _ = _cogent_debug_u32 sum_offs
    and _ = _cogent_debug "\n"
    and ((ex, ostore_st), r) = ostore_read_sum_extra_pages (ex, mount_st, ostore_st {rbuf}, ebnum, sum_offs)
    in r
    | Error e -> ((ex, ostore_st), Error e)
    | Success () ->
      let ostore_st {sum_obj, summary} = ostore_st
      and ((ex, sum_obj, summary), r) = deserialise_ObjSummary_crc(ex, ostore_st.rbuf, sum_offs, sum_obj, summary) !ostore_st
      and ostore_st = ostore_st {sum_obj, summary}
      in r
      | Error e ->
        ((ex, ostore_st), Error e)
      | Success _ ->
        ((ex, ostore_st), Success sum_offs)

ostore_clean: (ExState, OstoreState) -> ExState
ostore_clean(ex, ostore_st {rbuf,wbuf,opad,pools,fsm_st,index_st,ubi_vol,summary,sum_obj}) =
  let ex = buf_free(ex, rbuf)
  and ex = buf_free(ex, wbuf)
  and ex = deep_freeObj(ex, opad)
  and pools {idx=idxpool, gim=gimpool} = pools
  and ex = allocpool_free[RbtIndexNode] (ex, idxpool)
  and ex = allocpool_free[RbtGimNode] (ex, gimpool)
  and ex = fsm_clean(ex, fsm_st)
  and index_st {addrs} = index_st
  and ex = rbt_free[ObjId, ObjAddr](ex, addrs)
  and ex = wubi_close(ex, ubi_vol)
  and ex = summary_clean(ex, summary)
  and ex = deep_freeObj(ex, sum_obj)
  and ex = freeOstoreState(ex, ostore_st)
  in ex

get_obj_oid: Obj! -> ObjId
get_obj_oid obj =
  obj.ounion
  | TObjInode o -> o.id
  | TObjData o -> o.id
  | TObjDentarr o -> o.id
  | TObjDel o -> o.id
  | _ -> nilObjId

print_obj_type: Obj! -> ()
print_obj_type obj =
  obj.ounion
  | TObjInode o -> _cogent_debug "inode"
  | TObjData o -> _cogent_debug "data"
  | TObjDentarr o -> _cogent_debug "dentarr"
  | TObjDel o -> _cogent_debug "del"
  | TObjPad o -> _cogent_debug "pad"
  | TObjSuper o -> _cogent_debug "super"
  | TObjSummary o -> _cogent_debug "summary"

ostore_alloc_inode: OstoreState -> RR OstoreState U32 ErrCode
ostore_alloc_inode(ostore_st) =
  let inum = ostore_st.next_inum !ostore_st
  in if inum < bilbyFsMaxInum then
    let ostore_st {next_inum} = ostore_st
    and next_inum = next_inum + 1
    in (ostore_st {next_inum}, Success inum)
  else
    (ostore_st, Error eNFile)

reinit_summary: ObjSummary -> ObjSummary
reinit_summary summary =
  summary {nb_sum_entry = 0, sum_offs = 0}

ostore_new_wbuf: (MountState!, OstoreState, U32) -> RR OstoreState () ErrCode
ostore_new_wbuf(mount_st, ostore_st {fsm_st}, osw_flags) =
-- This function allocates an erase-block that will represent wbuf.
-- We initialise the part of @ostore_st that relates to @wbuf.
-- It also, reinitialises ostore_st.summary
  let (fsm_st, r) = fsm_alloc_eb(mount_st, fsm_st, osw_flags)
  in r
  | Error err -> _cogent_assert False ; _bilbyfs_error "ostore_new_wbuf: fsm_alloc_eb failed\n" ; (ostore_st {fsm_st}, Error err)
  | Success wbuf_eb ->
    _cogent_debug "ostore_new_wbuf: Allocated eb=" ;
    _cogent_debug_u32 wbuf_eb ;
    _cogent_debug "\n" ;
    let ostore_st {used, sync_offs, wbuf, wbuf_eb=_, summary} = ostore_st {fsm_st}
    and summary = reinit_summary summary
    and ostore_st = ostore_st {used=0, sync_offs=0, wbuf, wbuf_eb, summary}
    in (ostore_st, Success ())

get_obj_trans: (U32, U32) -> ObjTrans
get_obj_trans(i, nb_objs) =
 _cogent_assert(nb_objs > 0) ;
 if i == nb_objs - 1 then
   bilbyFsTransCommit
 else
   bilbyFsTransIn

ostore_update_padding_obj:(Obj, U64, U32) -> Obj
ostore_update_padding_obj(obj {sqnum=_,len,trans}, sqnum, pad_sz) =
  let len = pad_sz + bilbyFsObjHeaderSize
  and trans = bilbyFsTransCommit
  -- len specifies the padding needed, (de)serialise_Obj treat @len bytes
  -- as padding
  in obj {sqnum,len,trans}

-- padding_to: returns the an offset indicating the position in the buffer we
-- need to pad to. The size of the padding area is: pad_to(...) - ostore_st.used
-- NOTE: The offset returned isn't always aligned, when a summary needs to
-- be written the offset leaves room for it.
padding_to: (MountState!, OstoreState!, U32) -> U32
padding_to(mount_st, ostore_st, osw_flags) =
  if is_set(osw_flags, ostoreWriteNewEb) then
    _cogent_debug "prepare_wbuf: ostoreWriteNewEb\n" ;
    if not mount_st.no_summary && ostore_st.used /= mount_st.super.eb_size then
      mount_st.super.eb_size - serialise_size_summary_Obj_with_extra (ostore_st.summary, 0)
    else
      mount_st.super.eb_size
  else
    align32(ostore_st.used, mount_st.super.io_size)

prepare_wbuf: (ExState, MountState!, OstoreState, U32) -> RR (ExState,OstoreState) () ErrCode
prepare_wbuf(ex, mount_st, ostore_st {wbuf}, pad_to) =
  let pad_sz = pad_to - ostore_st.used !ostore_st
  in if pad_sz < bilbyFsObjHeaderSize then
    let wbuf = buf_memset(wbuf, ostore_st.used, pad_sz, bilbyFsPadByte) !ostore_st
    and used = pad_to
    and _ = _cogent_debug "prepare_wbuf: Success, added padding (used="
    and _ = _cogent_debug_u32 used
    and _ = _cogent_debug ")\n"
    in ((ex, ostore_st {wbuf, used}), Success ())
  else
    let ostore_st {next_sqnum=sqnum} = ostore_st
    in safe_add64(sqnum, 1)
    | Error () -> ((ex, ostore_st {next_sqnum=sqnum, wbuf}), Error eOverflow)
    | Success (next_sqnum) ->
      let ostore_st {opad} = ostore_st
      -- Update opad's sqnum
      and opad = ostore_update_padding_obj(opad, sqnum, pad_sz - bilbyFsObjHeaderSize)
      and used = ostore_st.used !ostore_st
      and (wbuf, offs) = serialise_Obj (wbuf, used, opad) !opad
      and _ = _cogent_assert (offs == pad_to)
      and _ = _cogent_debug "prepare_wbuf: Success (used="
      and _ = _cogent_debug_u32 pad_to
      and _ = _cogent_debug ")\n"
      and ostore_st {summary,oaddr} = ostore_st {wbuf, opad, used=pad_to, next_sqnum}
      and oaddr = oaddr {ebnum = ostore_st.wbuf_eb, len=pad_sz, offs = used, sqnum} !ostore_st
      and (ex, ostore_st) = update_obj_pad(ex, mount_st, ostore_st, oaddr)
      and ostore_st = ostore_st {summary}
      in ((ex, ostore_st), Success ())

ostore_write_buf: (ExState, MountState!, OstoreState, U32, U32, U32) -> RR (ExState, OstoreState) () ErrCode
ostore_write_buf(ex, mount_st, ostore_st {ubi_vol}, sync_offs, nb_bytes, osw_flags) =
  if nb_bytes > 0 then
    let ((ex, ubi_vol), r) = (
      if not (is_set (osw_flags, ostoreWriteAtomEb)) then
        wubi_leb_write #{ex, ubi_vol, ebnum=ostore_st.wbuf_eb, robuf=ostore_st.wbuf, buf_offs=sync_offs, nb_bytes}
      else
        wubi_leb_change #{ex, ubi_vol, ebnum=ostore_st.wbuf_eb, robuf=ostore_st.wbuf, nb_bytes}
    ) !ostore_st
    in ((ex, ostore_st {ubi_vol}), r)
  else
    ((ex, ostore_st {ubi_vol}), Success ())

ostore_sync_summary_if_eb_new: (ExState, MountState!, OstoreState, U32) -> RR (ExState, OstoreState) () ErrCode
ostore_sync_summary_if_eb_new(ex, mount_st, ostore_st, osw_flags) =
  let used = ostore_st.used !ostore_st
  and sqnum = ostore_st.next_sqnum !ostore_st
  in if not mount_st.no_summary && is_set (osw_flags, ostoreWriteNewEb) &&
        used /= mount_st.super.eb_size then
    if sqnum + 1 < sqnum then
      _cogent_debug "ostore_sync_summary_if_eb_new: ran out of sequence numbers\n" ;
      ((ex, ostore_st), Error eOverflow)
    else
      let ostore_st {wbuf, sum_obj, used} = ostore_st
      and len = serialise_size_summary_Obj_with_extra (ostore_st.summary, 0) !ostore_st
      and sum_obj = sum_obj {sqnum, offs=used, trans=bilbyFsTransCommit, len} 
      and ostore_st {summary} = ostore_st
      and summary = summary {sum_offs = used}
      and (sum_obj, wbuf, offs) = serialise_ObjSummary_crc(wbuf, used, sum_obj, summary) !summary
      and _ = _cogent_assert (used + len == offs)
      and ostore_st = ostore_st {next_sqnum = sqnum+1, wbuf, used=used+len, sum_obj, summary}
      in ((ex, ostore_st), Success ())
  else
    ((ex, ostore_st), Success ())

ostore_sync:(ExState, MountState!, OstoreState, U32) -> RR (ExState, OstoreState) () ErrCode
ostore_sync(ex, mount_st, ostore_st, osw_flags) =
-- Writes everything from sync_offs to align(used, io_size)
-- Uses padding objects to fill up align(used,io_size) - used
-- Note that if is_set(osw_flags, ostoreWriteNewEb) is true, we fill up
-- to eb_size instead of io_size.
-- If no other transaction can fit in the remaining space or
-- ostoreWriteNewEb is set, ostore_sync allocates a new erase-block
-- for future transactions.
-- ostoreWriteNewEb ensures that the erase-block is filled with a
-- padding object.

  let sync_offs = ostore_st.sync_offs !ostore_st
  and used = ostore_st.used !ostore_st
  and _ = _cogent_debug "ostore_sync: used="
  and _ = _cogent_debug_u32 used
  and _ = _cogent_debug " sync_offs="
  and _ = _cogent_debug_u32 sync_offs
  and _ = _cogent_debug " osw_flags ="
  and _ = _cogent_debug_u32 osw_flags
  and _ = _cogent_debug "\n"
  in if sync_offs == used && not (is_set (osw_flags, ostoreWriteNewEb)) then
    -- we are in sync with the buffer
    ((ex, ostore_st), Success ())
  else
    -- proof that prepare_wbuf does not change sync_offs required
    let pad_to = padding_to (mount_st, ostore_st, osw_flags) !ostore_st
    and ((ex, ostore_st), r) = prepare_wbuf(ex, mount_st, ostore_st, pad_to)
    -- depending on whether mount_st.no_summary, ostore.used is aligned or ostore.used + sum_size == eb_size
    in r
    | Error e ->
      _bilbyfs_error "ostore_sync: prepare_wbuf failed\n" ;
      ((ex, ostore_st), Error e)
    | Success () ->
      let ((ex, ostore_st), r) = ostore_sync_summary_if_eb_new(ex, mount_st, ostore_st, osw_flags)
      -- at this point ostore_st.used must be aligned to io_size
      and _ = _cogent_assert(align32(ostore_st.used, mount_st.super.io_size) == ostore_st.used) !ostore_st
      -- if not no_summary, summary information must be consistent with contents of erase-block
      in r
      | Error e ->
        _bilbyfs_error "ostore_sync: ostore_sync_summary failed\n" ;
        ((ex, ostore_st), Error e)
      | Success () ->
        let nb_bytes = ostore_st.used - sync_offs !ostore_st
        and ((ex, ostore_st), r) = ostore_write_buf (ex, mount_st, ostore_st, sync_offs, nb_bytes, osw_flags) !mount_st
        in r
        | Error e ->
          _bilbyfs_error("ostore_sync: ostore_write_buf failed\n") ;
          ((ex, ostore_st), Error e)
        | Success () ->
          let used = ostore_st.used !ostore_st
          -- FIXME Update fsm
          and ostore_st = ostore_st {sync_offs=used}
          in ((ex, ostore_st), Success ())

ostore_sync_new_eb:(ExState, MountState!, OstoreState, U32) -> RR (ExState, OstoreState) () ErrCode
ostore_sync_new_eb(ex, mount_st, ostore_st, osw_flags) =
  let ((ex, ostore_st), r) = ostore_sync (ex, mount_st, ostore_st, osw_flags) 
  and used = ostore_st.used !ostore_st
  in if used == mount_st.super.eb_size then
    let (ostore_st, r) = ostore_new_wbuf(mount_st, ostore_st, osw_flags)
    in r
    | Error e ->
      _bilbyfs_error("ostore_sync_new_eb: ostore_new_wbuf failed\n") ;
      ((ex, ostore_st), Error e)
    | Success () -> ((ex, ostore_st), Success ())
  else
    ((ex, ostore_st), Success ())

{-# cinline trans_size_loop_body #-}
trans_size_loop_body: #{elem:Obj!, acc:U32, obsv:()} -> U32
trans_size_loop_body #{elem=obj, acc=trans_size, obsv=_} =
  trans_size + obj.len

{-# cinline ostore_get_trans_size #-}
ostore_get_trans_size: (Array Obj)! -> U32
ostore_get_trans_size(arr) =
-- The valid_objs_trans(arr) predicate should guarantee that
-- the array objects is well-formed and that it constitute a
-- transaction that fits in mount_st.super.eb_size.
-- Proving that we don't overflow can be derived from this
-- predicate.
  let trans_size:U32 = 0
  in array_fold_no_break[Obj,U32,()] #{arr, f=trans_size_loop_body, acc=trans_size, obsv=()}

sync_if_trans_too_big: (ExState, MountState!, OstoreState, U32, U32) -> RR (ExState, OstoreState) () ErrCode
sync_if_trans_too_big(ex, mount_st, ostore_st, osw_flags, trans_size) =
  let used = ostore_st.used !ostore_st
  and next_sqnum = ostore_st.next_sqnum !ostore_st
  in if mount_st.no_summary then
  -- Function guarantees that the transaction will fit in ostore_st.wbuf_eb
    if trans_size > mount_st.super.eb_size then
      _cogent_debug "sync_if_trans_too_big: trans_size > eb_size (" ;
      _cogent_debug_u32 trans_size ;
      _cogent_debug " < " ;
      _cogent_debug_u32  mount_st.super.eb_size ;
      _cogent_debug ")\n" ;
      ((ex, ostore_st), Error eInval)
    else if trans_size > mount_st.super.eb_size - used ||
            is_set (osw_flags, ostoreWriteForceSync) then
      ostore_sync_new_eb(ex, mount_st, ostore_st, osw_flags)
    else
      ((ex, ostore_st), Success ())
  else
   -- FIXME This only account for 1 extra summary entry, worst case should be 1 for each object in the
   -- trans
    let sum_size = serialise_size_summary_Obj_with_extra (ostore_st.summary, 0) !ostore_st
    and _ = _cogent_assert (used + sum_size <= mount_st.super.eb_size)
    in if used + trans_size + sum_size + bilbyFsObjSumEntrySize > mount_st.super.eb_size then
      ostore_sync_new_eb(ex, mount_st, ostore_st, osw_flags .|. ostoreWriteNewEb)
    else if is_set (osw_flags, ostoreWriteForceSync) then
      ostore_sync_new_eb(ex, mount_st, ostore_st, osw_flags)
    else
      ((ex, ostore_st), Success ())
    
sync_if_no_trans_fit: (ExState, MountState!, OstoreState, U32) -> RR (ExState, OstoreState) () ErrCode
sync_if_no_trans_fit(ex, mount_st, ostore_st, osw_flags) =
-- Synchronise if no more transaction can fit in the erase-block
-- Note that bilbyFsObjHeaderSize is not enough to fit a useful transaction
-- (the only valid transaction of ObjHeaderSize is a padding object).
  let used = ostore_st.used !ostore_st
  and min_useful_trans = bilbyFsObjHeaderSize + bilbyFsObjDelSize
  in if mount_st.no_summary then
  -- Function guarantees that the transaction will fit in ostore_st.wbuf_eb
    if used + min_useful_trans > mount_st.super.eb_size then
      ostore_sync(ex, mount_st, ostore_st, osw_flags .|. ostoreWriteNewEb)
    else if is_set (osw_flags, ostoreWriteForceSync) then
      ostore_sync(ex, mount_st, ostore_st, osw_flags)
    else
      ((ex, ostore_st), Success ())
  else
   -- FIXME we should align used to io_size because ostore_sync might be called and could
   -- potentially not leave enough space for the summary

  -- No extra summary entry accounted for because best case scenario, we reuse an existing entry.
    let sum_size = serialise_size_summary_Obj_with_extra (ostore_st.summary, 0) !ostore_st
    and _ = _cogent_assert (used + sum_size <= mount_st.super.eb_size)
    in if used + min_useful_trans + sum_size > mount_st.super.eb_size then
      ostore_sync(ex, mount_st, ostore_st, osw_flags .|. ostoreWriteNewEb)
    else if is_set (osw_flags, ostoreWriteForceSync) then
      ostore_sync(ex, mount_st, ostore_st, osw_flags)
    else
      ((ex, ostore_st), Success ())

write_objects_loop_body: #{elem:Obj, acc:(Buffer, U32, U64, U32), obsv:U32} -> LoopResult (#{elem:Obj, acc:(Buffer, U32, U64, U32)}) (#{elem:Obj, rbrk:(ErrCode, Buffer)})
write_objects_loop_body #{elem=obj, acc=(buf, used, sqnum, i), obsv=nb_objs} =
  if sqnum+1 < sqnum then
    Break #{elem=obj, rbrk=(eOverflow, buf)}
  else
    let obj {sqnum=_, offs, trans} = obj
    and trans = get_obj_trans(i, nb_objs)
    and obj = obj {sqnum, offs=used, trans}
    and (buf, offs, obj) = serialise_Obj_crc(buf, used, obj)

    and obj {ounion} = obj
    and _ = _print_ObjHeader obj !obj
    and obj = obj {ounion}

    in Iterate #{elem=obj, acc=(buf, offs, sqnum+1, i+1)}

write_objects: (Buffer, U32, U64, Array Obj) -> RR (Buffer, Array Obj, U32) U64 ()
write_objects(buf, used, next_sqnum, arr) =
  let i:U32 = 0
  and nb_objs = array_length[Obj] arr !arr
  in array_map_ex[Obj, (Buffer, U32, U64, U32), U32, (ErrCode, Buffer)]
       #{arr, frm=0, to=nb_objs, f=write_objects_loop_body, acc=(buf, used, next_sqnum, i), obsv=nb_objs}
  | Break #{arr, rbrk=(e, buf)} -> ((buf, arr, e), Error ())
  | Iterate #{arr, acc=(buf, used, next_sqnum, _)} ->
    ((buf, arr, used), Success next_sqnum)

{-# cinline set_node #-}
set_node: (RbtIndexNode, ObjId, ObjAddr!) -> RbtIndexNode
set_node(node, oid, oaddr) =
  _cogent_debug "set_node: Found it, updating node\n" ;
  let node = rbtnode_put_key[ObjId, ObjAddr](node, oid)
  in rbtnode_put_val[ObjId, ObjAddr](node, oaddr)

update_obj_modifier: #{elem:RbtIndexNode, acc:(AllocPool RbtGimNode, FsmState, ExState), obsv:(MountState, ObjId, ObjAddr)!} -> (RbtIndexNode, (AllocPool RbtGimNode, FsmState, ExState))
update_obj_modifier #{elem=oldnode, acc=(gimpool, fsm_st, ex), obsv=(mount_st, oid, oaddr)} =
  let val = rbtnode_get_val[ObjId, ObjAddr] oldnode !oldnode
  and oldsqnum = val.sqnum
  in if oldsqnum < oaddr.sqnum then
    _cogent_debug "update_obj_modifier (oldsqnum < newsqnum) " ;
    _cogent_debug_u64_hex oid ;
    _cogent_debug "\n" ;
    -- If the node in the tree is older than @oaddr,
    -- we replace it by @oaddr.
    let (ex, fsm_st, gimpool) = fsm_mark_dirty(ex, mount_st, fsm_st, gimpool, oid, oaddr)
    and oldnode = set_node(oldnode, oid, oaddr)
    in (oldnode, (gimpool,fsm_st,ex))
  else
    _cogent_debug "update_obj_modifier keep oldsqnum " ;
    _cogent_debug_u64_hex oid ;
    _cogent_debug "\n" ;
    (oldnode, (gimpool,fsm_st,ex))

update_obj_use: #{elem:RbtIndexNode, acc:(Rbt ObjId ObjAddr, AllocPool RbtGimNode, FsmState, ExState), obsv:(MountState, ObjId, ObjAddr)!} -> (Rbt ObjId ObjAddr, AllocPool RbtGimNode, FsmState, ExState)
update_obj_use #{elem=node, acc=(addrs, gimpool,  fsm_st, ex), obsv=(mount_st, oid, oaddr)} =
  _cogent_debug "update_obj_use " ;
  _cogent_debug_u64_hex oid ;
  _cogent_debug "\n" ;
  let node = rbtnode_put_val[ObjId, ObjAddr](node, mkObjAddr)
  and #{rbt=addrs, optnode, acc=(gimpool, fsm_st, ex)} =
        rbt_modify[ObjId, ObjAddr,(AllocPool RbtGimNode, FsmState, ExState),(MountState, ObjId, ObjAddr)]
          #{rbt=addrs, key=oid, f=update_obj_modifier, node, acc=(gimpool,fsm_st,ex), obsv=(mount_st, oid, oaddr)}
  and ex = freeOptRbtNode[ObjId, ObjAddr](ex, optnode)
  in (addrs, gimpool, fsm_st, ex)

update_obj:(ExState, MountState!, OstoreState take (oaddr, summary), ObjId, ObjAddr) -> (ExState, OstoreState take (summary))
update_obj(ex, mount_st, ostore_st {index_st,fsm_st,pools}, oid, oaddr) =
  let index_st {addrs} = index_st
  and pools {idx,gim} = pools
  and (idx, (addrs, gim, fsm_st, ex)) =
        allocpool_use[RbtIndexNode, (Rbt ObjId ObjAddr, AllocPool RbtGimNode, FsmState, ExState), (MountState!, U64, ObjAddr!)]
          #{pool=idx, f=update_obj_use, acc=(addrs, gim, fsm_st, ex), obsv=(mount_st, oid, oaddr)} !oaddr
  and pools = pools {idx, gim}
  and index_st = index_st {addrs}
  and ostore_st = ostore_st {index_st, fsm_st, pools}
  in (ex, ostore_st {oaddr})

type DeleteObjAccs = (ExState, FsmState, AllocPool RbtGimNode)

should_delete: (#{elem:RbtIndexNode, acc:DeleteObjAccs, obsv:(MountState, ObjAddr)!})! -> Bool
should_delete #{elem = node, acc=(ex, fsm_st, gimpool), obsv=(mount_st, oaddr)} =
  _cogent_debug "should_delete: val.sqnum < oaddr.sqnum " ;
  let val = rbtnode_get_val[ObjId, ObjAddr] node
  and _ = _cogent_debug_u64 val.sqnum
  and _ = _cogent_debug " < "
  and _ = _cogent_debug_u64 oaddr.sqnum
  and _ = _cogent_debug "\n"
  in val.sqnum < oaddr.sqnum

delete_single_obj: #{elem:RbtIndexNode, acc:DeleteObjAccs, obsv:(MountState, ObjAddr)!} -> DeleteObjAccs
delete_single_obj #{elem = node, acc=(ex, fsm_st, gimpool), obsv=(mount_st, oaddr)} =
  _cogent_debug "deleting node " ;
  let val = rbtnode_get_val[ObjId, ObjAddr] node !node
  and oid = rbtnode_get_key[ObjId, ObjAddr] node !node
  and _ = _cogent_debug_u64_hex oid
  and _ = _cogent_debug "\n"
  and (ex, fsm_st) = fsm_mark_dirty_recycle(ex, mount_st, fsm_st, oid, val, idx_to_gim_node node)
  in (ex, fsm_st, gimpool)

delete_obj:(ExState, MountState!, OstoreState take(oaddr, summary), ObjId, ObjAddr) -> (ExState, OstoreState take (summary))
delete_obj(ex, mount_st, ostore_st {index_st,fsm_st,pools}, oid, oaddr) =
  let index_st {addrs} = index_st
  in if obj_id_is_dentarr(oid) then
    let pools {gim} = pools
    and (addrs, (ex,fsm_st, gim)) =
          rbt_cond_erase[ObjId, ObjAddr, DeleteObjAccs, (MountState, ObjAddr)]
            #{rbt=addrs, key=oid, cond=should_delete, f=delete_single_obj, acc=(ex,fsm_st,gim), obsv=(mount_st, oaddr)} !oaddr
    and pools = pools {gim}
    and index_st = index_st {addrs}
    in (ex, ostore_st {index_st, fsm_st, pools, oaddr})
  else
    let inum = inum_from_obj_id(oid)
    and oid_end = obj_id_end_mk(inum)
    and pools {gim} = pools
    and (ex, fsm_st, gim) = fsm_mark_dirty(ex, mount_st, fsm_st, gim, oid, oaddr) !oaddr
    and (addrs, (ex, fsm_st, gim)) =
          rbt_filter[ObjId, ObjAddr, DeleteObjAccs, (MountState, ObjAddr)]
            #{rbt=addrs, frm=oid, to=oid_end, cond=should_delete, f=delete_single_obj, acc=(ex, fsm_st, gim), obsv=(mount_st, oaddr)} !oaddr
    and pools = pools {gim}
    and index_st = index_st {addrs}
    in (ex, ostore_st {index_st, fsm_st, pools, oaddr})

update_obj_pad:(ExState, MountState!, OstoreState take(oaddr, summary), ObjAddr) -> (ExState, OstoreState take(summary))
update_obj_pad(ex, mount_st, ostore_st {fsm_st,pools}, oaddr) =
  let pools {gim} = pools
  and (ex, fsm_st, gim) = fsm_mark_dirty(ex, mount_st, fsm_st, gim, nilObjId, oaddr) !oaddr
  and pools = pools {gim}
  and ostore_st = ostore_st {fsm_st,pools}
  in (ex, ostore_st {oaddr})

trimObjSuper: ObjUnion! -> (ObjUnion take (TObjSummary, TObjSuper))!
trimObjSuper u = u
  | TObjSummary _   -> TObjPad ()
  | TObjSuper _ -> TObjPad ()
  | o -> o

proc_obj: (ExState, MountState!, OstoreState take (summary), Obj!, U32) -> (ExState, OstoreState take (summary))
proc_obj(ex, mount_st, ostore_st {oaddr}, obj, ebnum) =
  let oaddr {ebnum=_,sqnum=_,offs=_,len=_} = oaddr
  and oaddr = oaddr {ebnum, sqnum=obj.sqnum, offs=obj.offs, len=obj.len} !ostore_st
  and _ = _cogent_debug "proc_obj (oid="
  and _ = _cogent_debug_u64_hex (get_obj_oid obj)
  and _ = _cogent_debug ",type="
  and _ = print_obj_type obj
  and _ = _cogent_debug ")\n"
  in trimObjSuper obj.ounion
    | TObjInode v -> update_obj(ex, mount_st, ostore_st, v.id, oaddr)
    | TObjDentarr v -> update_obj(ex, mount_st, ostore_st, v.id, oaddr)
    | TObjData v -> update_obj(ex, mount_st, ostore_st, v.id, oaddr)
    | TObjDel v -> delete_obj(ex, mount_st, ostore_st, v.id, oaddr)
    | _ -> update_obj_pad(ex, mount_st, ostore_st, oaddr)
  
find_sum_entry_del_f: #{elem: ObjSumEntry!, acc:U32, obsv:(ObjId, U64)} -> LoopResult U32 (Option (U32, U16))
find_sum_entry_del_f #{elem=entry, acc=idx, obsv=(oid, sqnum)} =
  let oid_type = obj_id_type oid
  -- FIXME check if this condition is correct (bitfields)
  in if oid_type == upcast bilbyFsObjTypeDentarr then
    if oid == entry.id then
      if entry.sqnum > sqnum then
        Break (None ())
      else
        Break (Some (idx, entry.count))
    else
      Iterate (idx+1)
  else
    if inum_from_obj_id oid == inum_from_obj_id entry.id && entry.id > oid then
      if entry.sqnum > sqnum then
        Break (None ())
      else
        Break (Some (idx, entry.count))
    else 
      Iterate (idx+1)

find_sum_entry_f: #{elem: ObjSumEntry!, acc:U32, obsv:(ObjId, U64)} -> LoopResult U32 (Option (U32, U16))
find_sum_entry_f #{elem=entry, acc=idx, obsv=(oid, sqnum)} =
  let oid_type = obj_id_type oid
  in if obj_sum_entry_is_del entry && oid_type /= upcast bilbyFsObjTypeDentarr then
    Iterate (idx+1)
  else
    if oid == entry.id then
      if entry.sqnum > sqnum then
        Break (None ())
      else
        Break (Some (idx, entry.count))
    else
      Iterate (idx+1)

find_sum_entry: (ObjSummary!, ObjId, U64, U8) -> R (U32, U16) ()
find_sum_entry(summary, oid, sqnum, otype) =
  (if otype == bilbyFsObjTypeDel
   then wordarray_fold[ObjSumEntry, U32, (ObjId, U64), (Option (U32, U16))]
       #{arr=summary.entries, frm=0, to=summary.nb_sum_entry, f=find_sum_entry_del_f, acc=0, obsv=(oid, sqnum)}
   else wordarray_fold[ObjSumEntry, U32, (ObjId, U64), (Option (U32, U16))]
       #{arr=summary.entries, frm=0, to=summary.nb_sum_entry, f=find_sum_entry_f, acc=0, obsv=(oid, sqnum)})
  | Break opt ->
    opt
    | None () -> Error ()
    | Some idx_n_cnt -> Success idx_n_cnt
  | Iterate _ ->
    Success (summary.nb_sum_entry, 0)

proc_obj_sum: (ExState, MountState!, OstoreState, Obj!) -> (ExState, OstoreState)
proc_obj_sum(ex, mount_st, ostore_st, obj) =
-- This is a totally unoptimised version of summary processing, but it should be functionally correct.
  let _ = _cogent_debug "proc_obj_sum (oid="
  and _ = _cogent_debug_u64_hex (get_obj_oid obj)
  and _ = _cogent_debug ",type="
  and _ = print_obj_type obj
  and _ = _cogent_debug ")\n"
  and id = get_obj_oid obj !obj
  in if id == nilObjId then
    (ex, ostore_st)
  else
    let sqnum = obj.sqnum !obj
    and otype = obj.otype !obj
    in find_sum_entry (ostore_st.summary, id, sqnum, otype) !ostore_st
    -- Error means the entry we are trying to update is
    -- overruled by an more recent entry (sqnum check).
    | Error () -> (ex, ostore_st)
    | Success (idx_entry, count) ->
      let len = obj.len !obj
      and del_flags_and_offs = if otype == bilbyFsObjTypeDel then bilbyFsSumEntryDelFlagMask else 0
      and del_flags_and_offs = del_flags_and_offs .|. obj.offs
      -- FIXME how do we know that this does not overflow?
      -- We should be able to use max obj per eb
      and count = count + 1
      and sum_entry:ObjSumEntry = #{id, sqnum, len, del_flags_and_offs, count}
      and ostore_st {summary} = ostore_st
      and summary {entries} = summary
      and #{arr=entries, acc=()} = wordarray_modify[ObjSumEntry, (), ObjSumEntry!]
                                     #{arr=entries, idx=idx_entry, f=proc_obj_sum_f, acc=(), obsv=sum_entry}

      -- increment if we created a new entry
      and nb_sum_entry = summary.nb_sum_entry !summary
      and nb_sum_entry = (if idx_entry == nb_sum_entry then nb_sum_entry+1 else nb_sum_entry)

      and summary = summary {nb_sum_entry, entries}
      in (ex, ostore_st {summary})

{-# inline proc_obj_sum_f #-}
proc_obj_sum_f: #{elem:ObjSumEntry, acc:(), obsv:ObjSumEntry} -> #{elem:ObjSumEntry, acc:()}
proc_obj_sum_f #{elem=_, acc=_, obsv=sum_entry} =
  #{elem=sum_entry, acc=()}

proc_sum_entry: (ExState, MountState!, OstoreState take (summary), ObjSumEntry, U32) -> (ExState, OstoreState take (summary))
proc_sum_entry(ex, mount_st, ostore_st, entry, ebnum) =
  let ostore_st {oaddr} = ostore_st
  and oaddr = oaddr {ebnum, offs=obj_sum_entry_offs entry, len=entry.len, sqnum=entry.sqnum}
  and (ex, ostore_st) = update_obj (ex, mount_st, ostore_st, entry.id, oaddr)
  and _ = (if inum_from_obj_id entry.id == 24 then
            _cogent_debug "proc_sum_entry: root inode eb=" ; _cogent_debug_u32 ebnum ; 
            _cogent_debug " offs=" ; _cogent_debug_u32 oaddr.offs ; _cogent_debug "\n"
           else
            ())
  in (ex, ostore_st {oaddr})

ostore_update_loop_body: #{elem:Obj!, acc:(ExState, OstoreState), obsv:MountState!} -> (ExState, OstoreState)
ostore_update_loop_body #{elem=obj, acc=(ex, ostore_st), obsv=mount_st} =
  let eb = ostore_st.wbuf_eb !ostore_st
  and ostore_st {summary} = ostore_st 
  and (ex,ostore_st) = proc_obj(ex, mount_st, ostore_st, obj, eb)
  and (ex,ostore_st) = proc_obj_sum(ex, mount_st, ostore_st {summary}, obj)
  in (ex, ostore_st)

ostore_update: (ExState, MountState!, OstoreState, (Array Obj)!) -> (ExState, OstoreState)
ostore_update(ex, mount_st, ostore_st, arr) =
  _cogent_debug "ostore_update arr.len = " ;
  _cogent_debug_u32 (array_length[Obj] arr) ;
  _cogent_debug "\n" ;
  array_fold_no_break[Obj, (ExState,OstoreState), MountState]
    #{arr, f=ostore_update_loop_body, acc=(ex, ostore_st), obsv=mount_st}

{-

If the transaction does not fit in the current erase-block, synchronise
current erase-block and alloc new one. (see sync_if_trans_too_big())

write_objects() prepare objects before writing them to medium, in
particular it initialises the transaction flags (In,Commit) and it sets
sequence numbers (sqnum) in FS objects.

If no more transaction can fit in the erase-block after that we synchronise
to flash and alloc a new one.
  
We pre-allocate all tree nodes for Index & Gim using allocpool_prealloc()

From now on, ostore_write() cannot return an error anymore.
Update trees data stuctures using pre-allocated nodes in ostore_update()

Clean up extra preallocated nodes, allocpool_clean()

ostoreWriteForceSync: Makes all changes to the medium synchronously.
This is different from calling ostore_write() followed by ostore_sync()
because ostoreWriteForceSync guarantees that the FS will not go in
read-only mode if a software induced error occurs (e.g. memory allocation).

-}
 
-- ostore_write() assumes that wbuf_eb is set to a value consistent with
-- fsm_st (i.e. is_used flag is set for wbuf_eb), and other parts of ostore_st.
-- 
-- See invariant on OstoreState, ostore_write() preserves that invariant.
ostore_write: (ExState, MountState!, OstoreState, Array Obj, U32) -> RR (ExState, OstoreState, Array Obj) () ErrCode
ostore_write(ex, mount_st, ostore_st, arr, osw_flags) =
  let next_sqnum = ostore_st.next_sqnum !ostore_st
  and trans_size = ostore_get_trans_size(arr) !arr
  and ((ex, ostore_st), r) = sync_if_trans_too_big(ex, mount_st, ostore_st, osw_flags, trans_size)
  in r
  | Error e -> ((ex, ostore_st, arr), Error e)
  | Success () ->
    let ostore_st {wbuf} = ostore_st
    and _ = _cogent_debug "call write_objects (eb="
    and _ = _cogent_debug_u32 ostore_st.wbuf_eb !ostore_st
    and _ = _cogent_debug ")\n"
    and ((wbuf, arr, used), r) = write_objects(wbuf, ostore_st.used, next_sqnum, arr) !ostore_st
    in r
    -- have objects serialised if successful
    -- obj.sqnum and obj.offs are set
    -- used/next_sqnum, remain unchanged
    | Error () ->
      ((ex, ostore_st {wbuf,next_sqnum}, arr), Error used)
    | Success sqnum  ->
      let ostore_st = ostore_st {wbuf}
      and ((ex, ostore_st), r) = ostore_alloc_pools(ex, ostore_st, array_nb_elem[Obj] arr) !arr
      in r
      | Error e ->
        ((ex, ostore_st {next_sqnum}, arr), Error e)
      | Success () ->
        let ostore_st = ostore_st {next_sqnum=sqnum}
        and ((ex, ostore_st), r) = sync_if_no_trans_fit(ex, mount_st, ostore_st, osw_flags)
        in r
        | Error e  -> ((ex, ostore_st {next_sqnum}, arr), Error e)
        | Success () ->
          let (ex, ostore_st) = ostore_update(ex, mount_st, ostore_st, arr) !arr
          and ostore_st {used=_} = ostore_st
          and ostore_st = ostore_st {used}
          and _ = _cogent_debug "ostore_update done\n"
          and (ex, ostore_st) = ostore_free_pools(ex, ostore_st)
          in ((ex, ostore_st, arr), Success ())

ostore_alloc_pools: (ExState, OstoreState, U32) -> RR (ExState, OstoreState) () ErrCode
ostore_alloc_pools(ex, ostore_st {pools}, nb_nodes) =
  _cogent_debug "preallocating " ;
  _cogent_debug_u32 nb_nodes ; 
  _cogent_debug " nodes in each pool\n" ;
  let pools {idx, gim} = pools
  and ((ex, idx), r) = allocpool_prealloc[RbtIndexNode]#{ex, pool=idx, nb=nb_nodes}
  in r
  | Error () ->
      let pools = pools {idx, gim}
      in ((ex, ostore_st {pools}), Error eNoMem)
  | Success () ->
    let ((ex, gim), r) = allocpool_prealloc[RbtGimNode]#{ex, pool=gim, nb=nb_nodes}
    in r
    | Error () ->
      let pools = pools {idx, gim}
      and (ex, ostore_st) = ostore_free_pools(ex, ostore_st {pools})
      in ((ex, ostore_st), Error eNoMem)
    | Success () ->
      let pools = pools {idx, gim}
      in ((ex, ostore_st {pools}), Success ())

ostore_free_pools: (ExState, OstoreState) -> (ExState, OstoreState)
ostore_free_pools(ex, ostore_st {pools}) =
  let pools {idx,gim} = pools
  and (ex, idx) = allocpool_clean[RbtIndexNode](ex, idx)
  and (ex, gim) = allocpool_clean[RbtGimNode](ex, gim)
  and pools = pools {idx, gim}
  in (ex, ostore_st {pools})

ostore_read: (ExState, MountState!, OstoreState, ObjId) -> RR (ExState, OstoreState) Obj ErrCode
ostore_read (ex, mount_st, ostore_st, oid) =
  index_get_addr (ostore_st.index_st, oid) !ostore_st
  | Error err ->
    _cogent_debug "Obj not found in index " ;
    _cogent_debug_u64_hex oid ;
    _cogent_debug "\n" ;
    ((ex, ostore_st), error[Obj] err) 
  | Success addr ->
    let wbuf_eb = ostore_st.wbuf_eb !ostore_st
    -- if we are trying to read an object that is in the current write-buffer
    and ((ex, ostore_st), r) = (if addr.ebnum == wbuf_eb then
      let ostore_st {wbuf} = ostore_st
      and wbuf = wbuf {bound=ostore_st.used} !ostore_st
      in deserialise_Obj (ex, wbuf, addr.offs) !wbuf
      | Error (e, ex) ->
        _cogent_debug "ostore_read: deserialise_Obj_crc from buffer failed\n" ;
        let wbuf = wbuf {bound=mount_st.super.eb_size}
        in ((ex, ostore_st {wbuf}), error[Obj] e)
      | Success (ex, obj, sz) ->
        let wbuf = wbuf {bound=mount_st.super.eb_size}
        in ((ex, ostore_st {wbuf}), success[Obj, ErrCode] obj)
     else
    -- We need to read the object from medium
       let ostore_st {rbuf} = ostore_st
       and ((ex, rbuf), r) = read_obj_pages_in_buf (ex, mount_st, ostore_st.ubi_vol, rbuf, addr) !ostore_st
       in r
       | Error e ->
         _cogent_debug "ostore_read: read_obj_pages_in_buf failed.\n" ;
         ((ex, ostore_st {rbuf}), error[Obj] e)
       | Success () ->
         deserialise_Obj (ex, rbuf, addr.offs) !rbuf
         | Error (e, ex) ->
           _cogent_debug "ostore_read: deserialise_Obj_crc from flash failed.\n" ;
           ((ex, ostore_st {rbuf}), error[Obj] e)
         | Success (ex, obj, sz) -> ((ex, ostore_st {rbuf}), success[Obj, ErrCode] obj)
    )
    in r
    | Success obj ->
    -- Sanity check to ensure that what we read from medium is the right object
      let oid' = get_obj_oid obj !obj
      in if oid == oid' then
        ((ex, ostore_st), Success obj)
      else
        _print_field_u64 ("oid" ,oid) ;
        _print_field_u64 ("oid'" ,oid') ;
        _cogent_assert False ;
        -- Fs should go in read-only mode as we have detected
        -- an inconsistency between index and medium
        ((deep_freeObj (ex, obj), ostore_st), Error eRoFs)
    | Error e -> ((ex, ostore_st), Error e)

read_obj_pages_in_buf: (ExState, MountState!, UbiVol!, Buffer, ObjAddr!) -> RR (ExState, Buffer) () ErrCode
read_obj_pages_in_buf (ex, mount_st, ubi_vol, buf, addr) =
  let io_size = mount_st.super.io_size
  and offs_in_page = addr.offs % io_size
  and offs = addr.offs - offs_in_page
  and offs_end = align32 (addr.offs + addr.len, io_size)
  and ((ex, buf), r) = wubi_leb_read #{ex, ubi_vol, ebnum=addr.ebnum, buf, buf_offs=offs, nb_bytes=offs_end - offs}
  in r
  | Success () ->
    ((ex, buf {bound=offs_end}), Success ())
  | Error e ->
    ((ex, buf), Error e)

check_flash_empty_loop: #{acc:(ExState), obsv:(UbiVol!), idx:U32} -> LRR ExState ErrCode
check_flash_empty_loop #{acc=ex, obsv=ubi_vol, idx=i} =
  let (ex, r) = wubi_is_mapped #{ex, ubi_vol, ebnum=i}
  in r
  | Error err ->
    (ex, Break err)
  | Success is_mapped ->
    if is_mapped then
      (ex, Break eNotEmpty)
    else
      (ex, Iterate ())

check_flash_is_empty: (ExState, MountState!, UbiVol!) -> RR ExState Bool ErrCode
check_flash_is_empty(ex, mount_st, ubi_vol) =
  let (ex, r) = seq32[ExState, UbiVol, ErrCode]
                  #{frm=0, to=mount_st.super.nb_eb, step=1, f=check_flash_empty_loop, acc=ex, obsv=ubi_vol}
  in r
  | Break err ->
    if err == eNotEmpty then 
      (ex, Success False)
    else
      (ex, Error err)
  | Iterate () ->
    (ex, Success True)

type DelObjs = List DelNode

deep_opt_freeObj: (ExState, Option Obj) -> ExState
deep_opt_freeObj(ex, opt_obj) =
  opt_obj
  | None () -> ex
  | Some o ->
    _cogent_assert False ;
    deep_freeObj(ex, o)

scan_trans_obj: #{oelem:Option Obj, acc:(ExState, U32), obsv:(MountState, Buffer)!} -> LoopResult (Option Obj, (ExState, U32)) (Option Obj, R (ExState, U32) (ErrCode, ExState))
scan_trans_obj #{oelem=obj_opt, acc=(ex, offs), obsv=(mount_st, buf)} =
  let ex = deep_opt_freeObj(ex, obj_opt)
  in deserialise_Obj_crc(ex, buf, offs)
  | Error (err, ex) ->
    -- Error happened when deserialising an object
    -- return eRecover
    Break (None (), Error (eRecover, ex))
  | Success (ex, obj, offs) ->
    -- Surely there are checks we should do here?
    let trans = obj.trans !obj
    in if trans == bilbyFsTransCommit then
      Break (Some obj, Success (ex, offs))
    else
      if offs >= mount_st.super.eb_size then
    -- It seems that we should not allow recovery
    -- if we reach end of buffer with an unfinished
    -- transaction, something really wrong happened
    -- We return a non-recoverable error for this.
        let ex = deep_freeObj(ex, obj)
        in Break (None (), Error (eInval, ex))
      else
        Iterate (Some obj, (ex, offs))
    
object_eraser: #{elem:Obj, acc:ExState, obsv:()} -> RR ExState () Obj
object_eraser #{elem=obj, acc=ex, obsv=_} =
  (deep_freeObj(ex, obj), Success ())

new_delnode_init: (ExState, Obj!, U32) -> R (ExState, ListNode DelNode) ExState 
new_delnode_init(ex, obj, ebnum) =
  newListNode[DelNode](ex)
  | Error ex -> Error ex
  | Success (ex, del) ->
      let oaddr = #{ebnum,offs=obj.offs,len=obj.len,sqnum=obj.sqnum}
      and del = listnode_put[DelNode](del, #{id=get_obj_oid(obj),oaddr})
      in  Success (ex, del)

proc_obj_or_objsdel_loop: #{elem:Obj!, acc:(ExState, OstoreState take (summary), DelObjs), obsv:(MountState, U32)!} -> LoopResult (ExState, OstoreState take (summary), DelObjs) (ExState, OstoreState take (summary), DelObjs)
proc_obj_or_objsdel_loop #{elem=obj, acc=(ex, ostore_st, objsdel), obsv=(mount_st,eb)} =
 let is_del =
   (obj.ounion
    | TObjDel v -> True
    | _ -> False)
  in if is_del then
    new_delnode_init(ex, obj, eb)
    | Error ex -> Break (ex, ostore_st, objsdel)
    | Success (ex, node) ->
      let objsdel = list_add_node[DelNode](objsdel, node)
      in Iterate (ex, ostore_st, objsdel)
  else
    let (ex,ostore_st) = proc_obj(ex, mount_st, ostore_st, obj, eb)
    in Iterate (ex, ostore_st, objsdel)

scan_transaction: (ExState, MountState!, OstoreState, DelObjs, Array Obj, U32, U32) -> RR (ExState, OstoreState, DelObjs, Array Obj) U32 ErrCode
scan_transaction(ex, mount_st, ostore_st, objsdel, objs, eb, offs) =
  let len = array_length[Obj] objs !objs
  in array_map[Obj, (ExState,U32), (MountState, Buffer), R (ExState, U32) (ErrCode,ExState)]
       #{arr=objs, frm=0, to=len, f=scan_trans_obj, acc=(ex, offs), obsv=(mount_st, ostore_st.rbuf)} !ostore_st
  -- has to set objs.offs correctly
  | Iterate (objs, (ex, offs)) ->
    _cogent_debug "Too many objects in transaction" ;
    -- Not eRecover because this does not look like a crash symptom
    ((ex, ostore_st, objsdel, objs), Error eInval)
  | Break (objs, res) ->
    res
    | Error (err, ex) ->
      -- We do not return an offset because the caller already has offs
       ((ex, ostore_st, objsdel, objs), Error err)
    | Success (ex, offs) ->
      -- preallocate tree nodes
      let nb_nodes = array_nb_elem[Obj] objs !objs
      and ((ex, ostore_st), r) = ostore_alloc_pools(ex, ostore_st, nb_nodes)
      in r
      | Error e  -> ((ex, ostore_st, objsdel, objs), Error e)
      | Success () ->
      -- Process the transaction to update the OstoreState (i.e. Index & Fsm)
        let ostore_st {summary} = ostore_st
        in array_fold[Obj, (ExState, OstoreState take (summary), DelObjs),
                      (MountState, U32), (ExState, OstoreState take (summary), DelObjs)]
             #{arr=objs, f=proc_obj_or_objsdel_loop, acc=(ex, ostore_st, objsdel), obsv=(mount_st, eb)} !objs
        | Break (ex, ostore_st, objsdel) ->
          let ostore_st = ostore_st {summary}
          and (ex, ostore_st) = ostore_free_pools(ex, ostore_st)
          -- This should not be eRecover because malloc returned an error.
          in ((ex, ostore_st, objsdel, objs), Error eInval)
        | Iterate (ex, ostore_st, objsdel) ->
          let ostore_st = ostore_st {summary}
          and (ex, ostore_st) = ostore_free_pools(ex, ostore_st)
          -- All objects of the transaction have been processed
          -- sucessfully
          in ((ex, ostore_st, objsdel, objs), Success offs)

scan_transaction_loop: #{acc:(ExState, OstoreState, DelObjs, Array Obj, U32), obsv:(MountState, U32)!, idx:U32} ->
    LRR (ExState, OstoreState, DelObjs, Array Obj, U32) (R () ErrCode)
scan_transaction_loop #{acc=(ex, ostore_st, objsdel, objs, offs), obsv=(mount_st, eb), idx=nb_trans} =
-- objs array comes in "empty" (i.e. all entries are None) and has
-- to come out "empty".
  let ((ex, ostore_st, objsdel, objs), r) = scan_transaction(ex, mount_st, ostore_st, objsdel, objs, eb, offs)
  in r
  | Error err ->
    _cogent_debug "scan_transaction_loop: could not parse transaction at offset " ;
    _cogent_debug_u32 offs ;
    _cogent_debug " err=" ;
    _cogent_debug_u32 err ;
    _cogent_debug "\n" ;
    let #{arr=objs, acc=ex} = array_filter[Obj, ExState, ()] #{arr=objs, f=object_eraser, acc=ex, obsv=()}
    -- Could not parse transaction at offset offs
    -- Check if we landed in a padding area (i.e. area of padding too small for an ObjPad)
    and aligned_offs = align32(offs, mount_st.super.io_size)
    in if aligned_offs - offs < bilbyFsObjHeaderSize then
       if aligned_offs == mount_st.super.eb_size then
         _cogent_debug "scan_transaction_loop: We hit padding at end of block, onto next block\n" ;
         ((ex, ostore_st, objsdel, objs, 0), Break (Success ())) -- offs is ignore on break
       else
         _cogent_debug "scan_transaction_loop: We hit padding, next trans in block\n" ;
         if aligned_offs == offs then
           -- We found a non-finished block with 0xff, schedule recovery
           ((ex, ostore_st, objsdel, objs, aligned_offs), Break (Error eRecover))
         else
           ((ex, ostore_st, objsdel, objs, aligned_offs), Iterate ())
    else
    -- Real error happened, this might be recoverable, propagate error code and
    -- provide the offset of the beginning of the invalid transaction
    -- This could potentially be an empty page too, the recovery process is in
    -- charge of figuring this out.
      let _ = _cogent_debug "Detected invalid transaction on flash, this might be recoverable\n"
      in ((ex, ostore_st, objsdel, objs, offs), Break (Error err))
  | Success offs' ->
    let #{arr=objs, acc=ex} = array_filter[Obj, ExState, ()] #{arr=objs, f=object_eraser, acc=ex, obsv=()}
    -- We successfully parsed and processed transaction
    in if offs' < mount_st.super.eb_size then
      _cogent_debug "scan_transaction_loop: OK, next trans in block\n" ;
    -- We simply provide the offset to try for the next transaction.
      ((ex, ostore_st, objsdel, objs, offs'), Iterate ())
    else
      _cogent_debug "scan_transaction_loop: OK, we reached end of erase-block\n" ;
      ((ex, ostore_st, objsdel, objs, 0), Break (Success ())) -- offs is unused when we break

mount_scan_rbuf: (ExState, MountState!, OstoreState, DelObjs, Array Obj, U32) -> RR (ExState, OstoreState, DelObjs, Array Obj) () (ErrCode, U32)
mount_scan_rbuf(ex, mount_st, ostore_st, objsdel, objs, eb) =
  let offs:U32 = 0
 -- This is the upper limit of the number of transaction, if they are
 -- all of size bilbyFsObjHeaderSize
  and max_nb_trans = mount_st.super.eb_size / bilbyFsObjHeaderSize
  and ((ex, ostore_st, objsdel, objs, offs), r) =
        seq32[(ExState, OstoreState, DelObjs, Array Obj, U32), (MountState,U32), (R () ErrCode)]
          #{frm=0, to=max_nb_trans + 1, step=1, f=scan_transaction_loop, acc=(ex, ostore_st, objsdel, objs, offs), obsv=(mount_st, eb)}
  in r
  | Iterate () ->
    _cogent_assert False ; -- Cannot happen, too many transactions to fit in the buffer
    ((ex, ostore_st, objsdel, objs), Error (eInval, offs))
  | Break res -> 
    res
    | Error err ->
      -- This could be eRecover or not, we just propagate.
      -- This could be empty page found too
      -- offs indicates the first invalid byte in the buffer.
      ((ex, ostore_st, objsdel, objs), Error (err, offs))
    | Success () ->
      ((ex, ostore_st, objsdel, objs), Success ())

new_delnode_sum_init: (ExState, ObjSumEntry, U32) -> R (ExState, ListNode DelNode) ExState 
new_delnode_sum_init(ex, sum_entry, ebnum) =
  newListNode[DelNode](ex)
  | Error ex -> Error ex
  | Success (ex, del) ->
      let oaddr = #{ebnum,offs=obj_sum_entry_offs sum_entry,len=sum_entry.len,sqnum=sum_entry.sqnum}
      and del = listnode_put[DelNode](del, #{id=sum_entry.id,oaddr})
      in  Success (ex, del)

type SumLoopAcc = (ExState, U32, OstoreState take (summary), DelObjs) 
scan_summary_proc_entry: #{elem:ObjSumEntry, acc:SumLoopAcc, obsv:(MountState, U32)!} -> LoopResult SumLoopAcc (SumLoopAcc, ErrCode)
scan_summary_proc_entry #{elem=sum_entry, acc=(ex, tot_used, ostore_st, objsdel), obsv=(mount_st,eb)} =
  -- FIXME sanity check sum_entry
  let ostore_st {fsm_st, pools} = ostore_st
  and pools {gim} = pools
  and (ex, fsm_st, gim) = fsm_set_garbage (ex, mount_st, fsm_st, gim, sum_entry.id, sum_entry.sqnum, sum_entry.count)
  and pools = pools {gim}
  and ostore_st = ostore_st {fsm_st, pools}
  in if not (obj_sum_entry_is_del sum_entry) then
    let (ex, ostore_st) = proc_sum_entry(ex, mount_st, ostore_st, sum_entry, eb)
    in (Iterate (ex, tot_used+sum_entry.len, ostore_st, objsdel))
  else
    new_delnode_sum_init(ex, sum_entry, eb)
    | Error ex -> Break ((ex, tot_used+sum_entry.len, ostore_st, objsdel), eNoMem)
    | Success (ex, node) ->
      let objsdel = list_add_node[DelNode](objsdel, node)
      in Iterate (ex, tot_used+sum_entry.len, ostore_st, objsdel)

mount_scan_summary: #{acc:(ExState, MountState, OstoreState, DelObjs), obsv:(), idx:U32} -> LRR (ExState, MountState, OstoreState, DelObjs) ErrCode
mount_scan_summary #{acc=(ex, mount_st, ostore_st {fsm_st}, objsdel), obsv=_, idx=eb} =
  let fsm_st = fsm_mark_used(mount_st, fsm_st, eb) !mount_st
  and ostore_st = ostore_st {fsm_st}
  and ((ex, ostore_st), r) = ostore_read_sum (ex, mount_st, ostore_st, eb) !mount_st
  in r
  | Error e ->
    ((ex, mount_st, ostore_st, objsdel), Break e)
  | Success sum_offs ->
    let sum_nb_entry = ostore_st.summary.nb_sum_entry !ostore_st
    and ((ex, ostore_st), r) = ostore_alloc_pools(ex, ostore_st, sum_nb_entry)
    in r
    | Error e ->
      ((ex, mount_st, ostore_st, objsdel), Break e)
    | Success () ->
      let ostore_st {summary} = ostore_st
      in wordarray_fold[ObjSumEntry, SumLoopAcc, (MountState, U32), (SumLoopAcc, ErrCode)]
           #{arr=summary.entries, frm=0, to=summary.nb_sum_entry,
             f=scan_summary_proc_entry, acc=(ex, 0, ostore_st, objsdel), obsv=(mount_st, eb)} !mount_st !summary
      | Break ((ex, tot_used, ostore_st, objsdel), e) ->
        let ostore_st = ostore_st {summary}
        and (ex, ostore_st) = ostore_free_pools(ex, ostore_st)
        in ((ex, mount_st, ostore_st, objsdel), Break e)
      | Iterate (ex, tot_used, ostore_st, objsdel) ->
        let ostore_st {fsm_st} = ostore_st {summary}
        and eb_size = mount_st.super.eb_size !mount_st
        and fsm_st = fsm_mark_ebnum_dirty(fsm_st, eb, eb_size - tot_used)
        and (ex, ostore_st) = ostore_free_pools(ex, ostore_st {fsm_st})
        in ((ex, mount_st, ostore_st, objsdel), Iterate ())

mount_scan_full_eb: #{acc:(ExState, MountState, OstoreState, DelObjs, Array Obj), obsv:(), idx:U32} -> LRR (ExState, MountState, OstoreState, DelObjs, Array Obj) ErrCode
mount_scan_full_eb #{acc=(ex, mount_st, ostore_st, objsdel, objs), obsv=_, idx=eb} =
  let ostore_st {fsm_st} = ostore_st
  and fsm_st = fsm_mark_used(mount_st, fsm_st, eb) !mount_st
  and ostore_st {rbuf} = ostore_st {fsm_st}
  and ((ex, rbuf), r) = wbuf_read_leb(ex, mount_st, ostore_st.ubi_vol, rbuf, eb) !mount_st !ostore_st
  in r
  | Error err ->
    ((ex, mount_st, ostore_st {rbuf}, objsdel, objs), Break err)
  | Success () ->
    let ostore_st = ostore_st {rbuf}
    and ((ex, ostore_st, objsdel, objs), r) = mount_scan_rbuf(ex, mount_st, ostore_st, objsdel, objs, eb) !mount_st
    in r
    | Error (err, offs) ->
      if err /= eRecover then
        _cogent_debug "mount_can_rbuf returned: unrecoverable error\n" ;
        ((ex, mount_st, ostore_st, objsdel, objs), Break err)
      else
        _cogent_debug "mount_can_rbuf returned: recoverable error\n" ;
        let eb_recovery = mount_st.eb_recovery  !mount_st
        and has_eb_to_recover = eb_recovery /= 0
        in if has_eb_to_recover then
          _cogent_debug "Multiple erase-blocks are invalid (" ;
          _cogent_debug_u32 eb_recovery ;
          _cogent_debug "," ;
          _cogent_debug_u32 eb ;
          _cogent_debug "), can't recover more than 1 erase-block, please run fsck\n" ;
          let mount_st = mount_st {eb_recovery = 0}
          in ((ex, mount_st, ostore_st, objsdel, objs), Break eBadF)
        else
          let mount_st = mount_st {eb_recovery = eb, eb_recovery_offs = offs}
          in ((ex, mount_st, ostore_st, objsdel, objs), Iterate ())
    | Success () ->
       _cogent_debug "mount_can_rbuf returned: success\n" ;
       ((ex, mount_st, ostore_st, objsdel, objs), Iterate ())


mount_scan_loop: #{acc:(ExState, MountState, OstoreState, DelObjs, Array Obj), obsv:(), idx:U32} -> LRR (ExState, MountState, OstoreState, DelObjs, Array Obj) ErrCode
mount_scan_loop #{acc=(ex, mount_st, ostore_st, objsdel, objs), obsv=(), idx=eb} =
  let (ex, r) = wubi_is_mapped #{ex, ubi_vol=ostore_st.ubi_vol, ebnum=eb} !ostore_st
  and no_summary = mount_st.no_summary !mount_st
  in r
  | Error err ->
    _cogent_debug "wubi_is_mapped error " ;
    _cogent_debug_u32 err ;
    _cogent_debug "\n" ;
    ((ex, mount_st, ostore_st, objsdel, objs), Break err)
  | Success is_mapped ->
    if not is_mapped then
      ((ex, mount_st, ostore_st, objsdel, objs), Iterate ())
    else if no_summary then 
      _cogent_debug "mount_scan_loop: is mapped, no summary option, reading the whole erase-block\n" ;
      mount_scan_full_eb #{acc=(ex, mount_st, ostore_st, objsdel, objs), obsv=(), idx=eb}
    else
      _cogent_debug "mount_scan_loop: is mapped, reading summary\n" ;
      let ((ex, mount_st, ostore_st, objsdel), r) = mount_scan_summary #{acc=(ex, mount_st, ostore_st, objsdel), obsv=(), idx=eb}
      in r
      | Break e ->
        if e == eNoMem then
          _cogent_debug "Error with summary, could not allocate memory, can't recover form this.\n" ;
          ((ex, mount_st, ostore_st, objsdel, objs), Break eNoMem)
        else
          _cogent_debug "Error with summary in eb = ";
          _cogent_debug_u32 eb ;
          _cogent_debug ", Scanning full erase-block \n" ;
          mount_scan_full_eb #{acc=(ex, mount_st, ostore_st, objsdel, objs), obsv=(), idx=eb}
      | Iterate () ->
        ((ex, mount_st, ostore_st, objsdel, objs), Iterate ())

fold_delete_obj: #{elem:(ListNode DelNode)!, acc:(ExState, OstoreState), obsv:MountState!} -> (ExState, OstoreState)
fold_delete_obj #{elem=delnode, acc=(ex, ostore_st {oaddr, summary}), obsv=mount_st} =
  let node = listnode_get[DelNode] delnode
  and (ex, ostore_st) = delete_obj(ex, mount_st, ostore_st, node.id, node.oaddr)
  in (ex, ostore_st {oaddr, summary})
  
proc_objsdel: (ExState, MountState!, OstoreState, DelObjs!) -> (ExState, OstoreState)
proc_objsdel(ex, mount_st, ostore_st, objsdel) =
  list_fold[DelNode, (ExState, OstoreState), MountState]
    #{list=objsdel, f=fold_delete_obj, acc=(ex, ostore_st), obsv=mount_st}

is_0xff: #{elem:U8, acc:(), obsv:()} -> LoopResult () ()
is_0xff #{elem=c, acc=_, obsv=_} =
  if c == 0xff then Iterate () else Break ()

eb_empty_pages_from: (Buffer!, U32) -> Bool
eb_empty_pages_from(buf, offs) =
 wordarray_fold[U8, (), (), ()] #{arr=buf.data, frm=offs, to=buf.bound, f=is_0xff, acc=(), obsv=()}
 | Break () -> False
 | Iterate () -> True

mount_recover: (ExState, MountState, OstoreState) -> RR (ExState, MountState, OstoreState) Bool ErrCode
mount_recover(ex, mount_st, ostore_st) =
  -- _cogent_assert (mount_st.eb_recovery_offs == align32(mount_st.eb_recovery_offs)) !mount_st ; 
  -- _cogent_assert (mount_st.eb_recovery_offs /= mount_st.eb_size) !mount_st ; 
  -- eb_recovery_offs is always on the next page and cannot be at the end of the buffer.
  let eb_recovery = mount_st.eb_recovery !mount_st
  in if eb_recovery == 0 then
    _cogent_debug "mount_recover: no inconsistent erase-block\n" ;
    ((ex, mount_st, ostore_st), Success True)
  else
    _cogent_debug "mount_recover: an erase-block is inconsistent, we recover\n" ;
    let ostore_st {used, sync_offs, wbuf, wbuf_eb=_} = ostore_st
    and eb_size = mount_st.super.eb_size !mount_st
    and wbuf = wbuf {bound=eb_size}
    and wbuf_eb = mount_st.eb_recovery !mount_st
    and offs = mount_st.eb_recovery_offs !mount_st
    -- set wbuf_eb, used and sync_offs
    and ostore_st = ostore_st {used=offs, sync_offs=offs, wbuf_eb}
    and ((ex, wbuf), r) = wbuf_read_leb(ex, mount_st, ostore_st.ubi_vol, wbuf, wbuf_eb) !mount_st !ostore_st
    in r
    | Error err ->
      ((ex, mount_st, ostore_st {wbuf}), Error err)
    | Success () ->
      -- FIXME when summary are enabled, we need to rebuild the summary up to the invalid transaction
      let has_empty_pages = eb_empty_pages_from(wbuf, used) !wbuf
      in if has_empty_pages then
        _cogent_debug "mount_recover: We detected that pages after offset " ;
        _cogent_debug_u32 used ;
        _cogent_debug " are all empty, we don't need to rewrite this erase-block\n" ;
        let mount_st {eb_recovery, eb_recovery_offs} = mount_st
        and mount_st = mount_st {eb_recovery=0, eb_recovery_offs=0}
        in ((ex, mount_st, ostore_st {wbuf}), Success False)
      else
        -- There is some garbage in the erase-block (e.g. an unfinished transaction)
        -- We need to restore the erase-block.
        -- Make sure the buffer is aligned to io_size
        let ostore_st = ostore_st {wbuf}
        and pad_to = padding_to (mount_st, ostore_st, ostoreWriteNone) !mount_st !ostore_st
        and ((ex, ostore_st), r) = prepare_wbuf(ex, mount_st, ostore_st, pad_to) !mount_st
        in r
        | Error err ->
          ((ex, mount_st, ostore_st), Error err)
        | Success () ->
          let ostore_st {ubi_vol, wbuf, used} = ostore_st
          and ((ex, ubi_vol), r) = wubi_leb_change #{ex, ubi_vol, ebnum=wbuf_eb, robuf=wbuf, nb_bytes=used} !wbuf
          in r
          | Error err ->
            -- Failed to recover, not much we can do...
            ((ex, mount_st, ostore_st {ubi_vol, wbuf, used}), Error err) 
          | Success () ->
            let mount_st {eb_recovery, eb_recovery_offs} = mount_st
            and mount_st = mount_st {eb_recovery=0, eb_recovery_offs=0}
            and allocneweb = (used == mount_st.super.eb_size) !mount_st
            in ((ex, mount_st, ostore_st {ubi_vol, wbuf, used, sync_offs = used}), Success allocneweb)

-- Success Bool indicates whether we need to allocate a new erase-block
mount_scan: (ExState, MountState, OstoreState) -> RR (ExState, MountState, OstoreState) Bool ErrCode
mount_scan(ex, mount_st, ostore_st) =
  list_create[DelNode](ex)
  | Error ex ->
    ((ex, mount_st, ostore_st), Error eNoMem)
  | Success (ex, objsdel) ->
    let nb_eb = mount_st.super.nb_eb !mount_st
    in array_create[Obj] (ex, bilbyFsMaxObjPerTrans)
    -- This could be allocated dynamically when summary are enabled, however
    -- the complexity/benefit trade-offs doesn't look too appealing
    | Error ex ->
      let ex = list_free[DelNode] #{list=objsdel, f=freeListNode[DelNode], ex}
      in ((ex, mount_st, ostore_st), Error eNoMem)
    | Success (ex, objs) ->
      let ((ex, mount_st, ostore_st, objsdel, objs), r) =
            seq32[(ExState, MountState, OstoreState, DelObjs, Array Obj), (), ErrCode]
              #{frm=bilbyFsFirstLogEbNum, to=nb_eb, step=1, f=mount_scan_loop, acc=(ex, mount_st, ostore_st, objsdel, objs), obsv=()}
      in r
      | Break err ->
         let ex = list_free[DelNode] #{list=objsdel, f=freeListNode[DelNode], ex}
         and ex = array_free[Obj] #{arr=objs, f=deep_freeObj, ex}
         in ((ex, mount_st, ostore_st), Error err)
      | Iterate () ->
          -- check for eb recovery
          -- call rbuf_to_wbuf(ostore_st, eb, offs)
          -- that checks and sets eb_recovery and eb_recovery_offs.
          -- rbuf_to_wbuf also copies rbuf from 0 to @offs in
          -- wbuf. When mount() is terminating, we will recover this
          -- erase-block, by first checking whether the data at @offs
          -- are empty pages or not. If we do nothing but assume
          -- we just allocated this erase-block.
          -- Otherwise, we use ubi_leb_change to recover the erase-block
          let ((ex, mount_st, ostore_st), r) = mount_recover(ex, mount_st, ostore_st)
          in r
          | Error err ->
            let ex = list_free[DelNode] #{list=objsdel, f=freeListNode[DelNode], ex}
            and ex = array_free[Obj] #{arr=objs, f=deep_freeObj, ex}
            in ((ex, mount_st, ostore_st), Error err)
          | Success alloc_neweb ->
             let (ex, ostore_st) = proc_objsdel(ex, mount_st, ostore_st, objsdel) !mount_st !objsdel
             and ex = list_free[DelNode] #{list=objsdel, f=freeListNode[DelNode], ex}
             and ex = array_free[Obj] #{arr=objs, f=deep_freeObj, ex}
             in ((ex, mount_st, ostore_st), Success alloc_neweb)

extract_super_from_union:(ExState, ObjUnion) -> R (ExState, ObjSuper) ExState
extract_super_from_union(ex, ounion) =
  ounion
  | TObjPad _       -> Error ex
  | TObjInode v     -> Error (deep_freeObjInode(ex,v))
  | TObjData v      -> Error (deep_freeObjData(ex,v))
  | TObjDel _       -> Error ex
  | TObjDentarr v   -> Error (deep_freeObjDentarr(ex,v))
  | TObjSummary sum -> Error (summary_clean(ex, sum))
  | TObjSuper sup   -> Success (ex, sup)

read_super_loop: #{acc:(ExState, Obj, U32), obsv:(MountState, Buffer)!, idx:U32} -> LRR (ExState, Obj, U32) ()
read_super_loop #{acc=(ex, obj, offs), obsv=(mount_st, rbuf), idx=nb_trans} =
  deserialise_Obj_crc(ex, rbuf, offs)
  | Error (err, ex) ->
    -- Ideally we should check that we are not in an padding area (too small to contain a pad object)
    -- But in practice I think we can prove that this never happens for the super-block erase-block.
    -- (probably means that super-block erase-block has a weaker invariant (i.e. more restrictive) than others)
    ((ex, obj, 0), Break ()) -- offset is ignored when we beak
  | Success (ex, obj', offs) ->
    let typ = obj'.otype !obj'
    in if typ /= bilbyFsObjTypeSuper then
      let ex = deep_freeObj(ex, obj')
      in ((ex, obj, offs), Iterate ())
    else
      let ex = deep_freeObj(ex, obj)
      in ((ex, obj', offs), Iterate ())

mount_read_super: (ExState, MountState, OstoreState) -> RR (ExState, MountState, OstoreState) () ErrCode
mount_read_super(ex, mount_st, ostore_st {rbuf}) =
-- Success means that mount_st.super is the one stored on-flash and
-- mount_st.super_offs corresponds to the offset.
  let ((ex, rbuf), r) = wbuf_read_leb(ex, mount_st, ostore_st.ubi_vol, rbuf, bilbyFsSuperEbNum) !mount_st !ostore_st
  in r
  | Error err ->
    _cogent_debug "mount_read_super: failed to read leb\n" ;
    ((ex, mount_st, ostore_st {rbuf}), Error err)
  | Success () ->
    _cogent_debug "mount_read_super: read leb\n" ;
    deserialise_Obj_crc(ex, rbuf, 0) !rbuf
    | Error (err, ex) ->
      -- If superblock is invalid, we need to run fsck
      _cogent_debug "mount_read_super: No super-block found at all, please run fsck.\n" ;
      ((ex, mount_st, ostore_st {rbuf}), Error err)
    | Success (ex, obj, offs) ->
      let ostore_st = ostore_st {rbuf}
     -- This is the upper limit of the number of transaction, if they are
     -- all of size bilbyFsObjHeaderSize
      and max_nb_trans = mount_st.super.eb_size / bilbyFsObjHeaderSize !mount_st
      and ((ex, obj, offs), r) =
            seq32[(ExState, Obj, U32), (MountState, Buffer), ()]
              #{frm=0, to=max_nb_trans + 1, step=1, f=read_super_loop, acc=(ex, obj, offs), obsv=(mount_st, ostore_st.rbuf)} !ostore_st !mount_st
      in r
      | Iterate () ->
        _cogent_assert False ; -- Cannot happen, too many transactions to fit in the buffer
        let ex = deep_freeObj(ex, obj)
        in ((ex, mount_st, ostore_st), Error eInval)
      | Break () ->
        _cogent_debug "mount_read_super() : after loop " ;
        let obj {ounion} = obj
        and _ = _print_ObjHeader obj !obj
        and obj {offs} = obj
        and obj {crc,magic,sqnum,len,trans,otype} = obj
        and ex = freeObj(ex, obj)
        in extract_super_from_union(ex, ounion)
        | Error ex ->
          _cogent_debug "mount_read_super: object found not a ObjSuper\n" ;
          ((ex, mount_st, ostore_st), Error eInval)
        | Success (ex, super') ->
          let mount_st {super,super_offs=_} = mount_st
          and ex = deep_freeObjSuper(ex, super)
          -- if we reached the end of the erase-block, restart from 0
          and super_offs = if offs == super'.eb_size then 0 else offs !super'
          and _ = _print_ObjSuper super' !super'
          and mount_st = mount_st {super=super',super_offs}
          and ostore_st = ostore_st {next_sqnum = mount_st.super.next_sqnum,
                                     next_inum = mount_st.super.last_inum + 1} !mount_st
          in ((ex, mount_st, ostore_st), Success ())

ostore_next_obj_id: (MountState!, OstoreState!, ObjId) -> R ObjId ()
ostore_next_obj_id(mount_st, ostore_st, oid) =
  rbt_next[ObjId, ObjAddr](ostore_st.index_st.addrs, oid)
  | Error () ->
    _cogent_debug "Nothing found in the tree\n" ;
    Error ()
  | Success next_oid ->
     _cogent_debug "found next " ; _cogent_debug_u64_hex next_oid ;
  -- We make sure that next_oid and oid are attached to the same inode number
    if inum_from_obj_id(oid) == inum_from_obj_id(next_oid) then
      _cogent_debug ", OK\n" ;
      Success next_oid
    else
      _cogent_debug "but is for another inode\n" ;
      Error ()

ostore_mount: (ExState, MountState, OstoreState) -> RR (ExState, MountState, OstoreState) () ErrCode
ostore_mount(ex, mount_st, ostore_st) =
  let (ex, r) = check_flash_is_empty(ex, mount_st, ostore_st.ubi_vol) !mount_st !ostore_st
  in r
  | Error err -> ((ex, mount_st, ostore_st), Error err)
  | Success is_empty ->
    if is_empty then
      ((ex, mount_st, ostore_st), Error eNoData)
    else
      let ((ex, mount_st, ostore_st), r) = mount_read_super(ex, mount_st, ostore_st)
      in r
      | Error err ->
        ((ex, mount_st, ostore_st), Error err)
      | Success () ->
      -- mount_st is consistent with ostore_st.ubi_vol
        let ((ex, mount_st, ostore_st), r) = mount_scan(ex, mount_st, ostore_st)
        in r
        | Error err ->
          ((ex, mount_st, ostore_st), Error err)
        | Success alloc ->
          if alloc then
            -- allocate new eb
            let (ostore_st, r) = ostore_new_wbuf(mount_st, ostore_st, ostoreWriteNone) !mount_st
            in r
            | Error err ->
              ((ex, mount_st, ostore_st), Error err)
            | Success () ->
              ((ex, mount_st, ostore_st), Success ())
          else
            ((ex, mount_st, ostore_st), Success ())

obj_init_default: (Obj take (..), U8) -> Obj take (ounion)
obj_init_default(obj, otype) = obj {magic=bilbyFsMagic,crc=0,sqnum=0,offs=0,len=0,trans=bilbyFsTransIn,otype}

obj_init_super: (Obj take (..), U64, U32) -> Obj take (ounion)
obj_init_super(obj, sqnum, offs) =
  let len = bilbyFsObjSuperSize + bilbyFsObjHeaderSize
  in obj {magic=bilbyFsMagic,crc=0,sqnum,offs,len,trans=bilbyFsTransCommit,otype=bilbyFsObjTypeSuper}

-- ostore_write_super is only called in umount and fsop_format_default
-- we can assume that the ostore_st.wbuf_eb and .used and .sync_offs
-- is gonna be updated afterwards (unless it doesn't matter)
ostore_write_super: (ExState, MountState, OstoreState) -> RR (ExState, MountState, OstoreState) () ErrCode
ostore_write_super (ex, mount_st, ostore_st) =
  let ((ex, ostore_st), r) = ostore_sync (ex, mount_st, ostore_st, ostoreWriteNone) !mount_st
  in r
  | Error err ->
    ((ex, mount_st, ostore_st), Error err)
  | Success () ->
    let next_sqnum = ostore_st.next_sqnum !ostore_st
    in if next_sqnum + 1 < next_sqnum then
      ((ex, mount_st, ostore_st), Error eOverflow)
    else
      let mount_st {super, obj_sup = obj} = mount_st

      and cur_eb = ostore_st.wbuf_eb !ostore_st
      and cur_offs = ostore_st.sync_offs !ostore_st
      and last_inum = ostore_st.next_inum - 1 !ostore_st
      and super = super {cur_eb, cur_offs, next_sqnum = next_sqnum+1, last_inum} !ostore_st

      and ostore_st = ostore_st {wbuf_eb=bilbyFsSuperEbNum,
            used=mount_st.super_offs, sync_offs=mount_st.super_offs} !mount_st
      and obj = obj_init_super(obj, next_sqnum, mount_st.super_offs) !mount_st
      and ostore_st = ostore_st {next_sqnum = next_sqnum+1} 
      and ostore_st {wbuf} = ostore_st
      and (ex, wbuf, used, obj) = serialise_Obj_Super_crc(ex, wbuf, mount_st.super_offs, obj, super) !mount_st !super
      and _ = _cogent_debug "ostore_write_super() : "
      and _ = _print_ObjHeader obj !obj
      and _ = _print_ObjSuper super !super
      and ostore_st = ostore_st {wbuf, used}
      and mount_st = mount_st {super, obj_sup = obj}
      and oswf = if mount_st.super_offs == 0 then ostoreWriteAtomEb else ostoreWriteNone !mount_st
      and ((ex, ostore_st), r) = ostore_sync(ex, mount_st, ostore_st, oswf) !mount_st
      and mount_st = mount_st {super_offs = ostore_st.used} !ostore_st
      in r
      | Error err ->
        _cogent_debug "Could not write super object\n" ;
        ((ex, mount_st, ostore_st), Error err)
      | Success () ->
        ((ex, mount_st, ostore_st), Success ())

ostore_umount: (ExState, MountState, OstoreState) -> RR (ExState, MountState, OstoreState) () ErrCode
ostore_umount(ex, mount_st, ostore_st) =
  let sqnum = ostore_st.next_sqnum !ostore_st
  and sup_sqnum = mount_st.super.next_sqnum !mount_st
  in if sup_sqnum < sqnum then
    let ((ex, ostore_st), r) = ostore_sync(ex, mount_st, ostore_st, ostoreWriteNewEb) !mount_st
    in r
    | Error err ->
      _cogent_debug "Could not synchronize FS when unmounting\n" ;
      ((ex, mount_st, ostore_st), Error err)
    | Success () ->
      ostore_write_super(ex, mount_st, ostore_st)
  else
    ((ex, mount_st, ostore_st), Success ())
