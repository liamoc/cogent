--
-- Copyright 2016, NICTA
--
-- This software may be distributed and modified according to the terms of
-- the GNU General Public License version 2. Note that NO WARRANTY is provided.
-- See "LICENSE_GPLv2.txt" for details.
--
-- @TAG(NICTA_GPL)
--

type FittingDirentsInPageAcc = (ExState, FsState, U64, U64)
type FittingDirentsInPageObsv = (CString!, U64, U16, OSPageBuffer, U64)
type FittingDirentsInPageRet = (U16, U16, Ext2DirEnt)

------------------------------------------------------------------------------
-- directory helpers
------------------------------------------------------------------------------

-- serialises a dirent over the top of an existing one
-- you usually use this to update a link to a different inode (aka ext2_set_link on LIN)
-- otherwise, dirent remains the same
-- TODO: rename (parent, dirent, target, dirent_context)
ext2_dir_update: (ExState, FsState, VfsInode, Ext2DirEnt!, VfsInode, OSPageContext) -> RR (ExState, FsState, VfsInode, VfsInode) () U32
ext2_dir_update (ex, state, dir, dirent, inode, ctx) =
    let ctx_t {page, buf, pos} = ctx
    and reclen = ext2_rec_len_from_disk (dirent.record_length)

    and page_locked = ospage_lock (page)

    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_update: using page pos ")
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, pos)
    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")

    and ((ex, state, page_locked), res) = ext2_prepare_chunk (ex, state, page_locked, upcast pos, upcast reclen)
    in res
    | Success () =>
        -- don't bother cloning
        -- basically, write over the top of dirent with the inode changed to whatever was passed in
        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_update: pointing dirent to ")
        and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, vfs_inode_get_ino (inode)) !inode
        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")

        and ((ex, buf, _), res) = serialise_Ext2DirEnt2 (ex, inode, reclen, dirent.name, dirent.name_length, buf, pos) !inode
        in res
        | Success () =>
            let (ex, state, page) = ext2_commit_chunk (ex, state, page_locked, upcast pos, upcast reclen)

            and page = ospage_unmap (page, buf)
            and page = ospage_unlock (page)
            and _ = ospagecache_release (page)

            -- TODO: update ctime, mtime, disable BTREE flag
            and (ex, dir) = vfs_inode_mark_dirty (ex, dir)
            in ((ex, state, dir, inode), Success ())
        | Error () ->
            let page_locked = ospage_unmap (page_locked, buf)
            and page = ospage_unlock (page_locked)
            and _ = ospagecache_release (page)

            in ((ex, state, dir, inode), Error eIO)
    | Error err ->
        let page_locked = ospage_unmap (page_locked, buf)
        and page = ospage_unlock (page_locked)
        and _ = ospagecache_release (page)

        in ((ex, state, dir, inode), Error err)

-- linux assumes that the first directory entry is always .. -- we don't (because it's a dumb assumption)
ext2_dir_get_parent: (ExState, FsState, VfsInode!) -> Result (ExState, FsState, Ext2DirEnt, OSPageContext) (ExState, FsState, U32)
ext2_dir_get_parent (ex, state, inode) =
    wordarray_create_nz[U8] (ex, 2)
    | Success (ex, dotdot) =>
        let dotdot = wordarray_put2[U8] #{ arr = dotdot, idx = 0, val = '.' }
        and dotdot = wordarray_put2[U8] #{ arr = dotdot, idx = 1, val = '.' }

        and ((ex, state), res) = ext2_find_entry_bang (ex, state, inode, dotdot) !dotdot
        in res
        | Success (de, page, buf, pos) =>
            let pagectx = #{ page, buf, pos }
            and ex = wordarray_free[U8] (ex, dotdot)

            in Success (ex, state, de, pagectx)
        | Error err ->
            let ex = wordarray_free[U8] (ex, dotdot)
            in Error (ex, state, err)
    | Error ex ->
        Error (ex, state, eNoMem)

------------------------------------------------------------------------------
-- adding to directory
------------------------------------------------------------------------------

get_next_dirent_from_page3: Generator Ext2DirEnt FittingDirentsInPageRet U32 FittingDirentsInPageAcc FittingDirentsInPageObsv 
get_next_dirent_from_page3(#{acc = (ex, state, prev_offset, offset), obsv = (name, dir_end, required_reclen, pagebuf, offset_limit)}) = 
    if offset <= offset_limit then
        let (ex, res) = deserialise_Ext2DirEnt2 (ex, pagebuf, u64_to_u32 offset) -- XXX: shouldn't downcast
        in res
        | Success (dirent, _) ->
            let new_offset = offset + upcast (ext2_rec_len_from_disk (dirent.record_length)) !dirent
            in ((ex, state, offset, new_offset), Yield dirent)
        | Error () ->
            let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("get_next_dirent_from_page3: failed to deser dirent while finding fitting\n"))
            in ((ex, state, prev_offset, offset), Stop eIO)
    else
        -- got to end of page
        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("get_next_dirent_from_page3: reached end of page ("))
        and _ = _cogent_log_u64 (dbg_EXT2_DIR_WRITE, (offset))
        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, (" > "))
        and _ = _cogent_log_u64 (dbg_EXT2_DIR_WRITE, (offset_limit))
        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, (")\n"))
        in ((ex, state, prev_offset, offset), Stop 0)

-- rec_len should be ondisk_reclen
-- reclen should be required_reclen
check_dirent_fits: Consumer Ext2DirEnt FittingDirentsInPageRet U32 FittingDirentsInPageAcc FittingDirentsInPageObsv
check_dirent_fits #{obj = dirent, acc = (ex, state, offset, new_offset), obsv = (name, dir_end, required_reclen, pagebuf, offset_limit)} =
    if offset == dir_end then
        -- we hit directory size
        let smallest_ondisk_reclen:U16 = 0
        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("check_dirent_fits: hit directory size at offset "))
        and _ = _cogent_log_u64 (dbg_EXT2_DIR_WRITE, offset)
        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, " and dirend =")
        and _ = _cogent_log_u64 (dbg_EXT2_DIR_WRITE, dir_end)
        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")
        and ondisk_reclen = ext2_rec_len_from_disk (u32_to_u16 const_blockSize) -- ext2_chunk_size
        and dirent = dirent { record_length = ondisk_reclen, inode = 0 }
        in ((ex, state, offset, new_offset), Return (smallest_ondisk_reclen, ondisk_reclen, dirent))
    else
        let ondisk_reclen = dirent.record_length !dirent
        in if ondisk_reclen == 0 then
            -- error, zero-length dir
            let ex = destroy_Ext2DirEnt (ex, dirent)
            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("check_dirent_fits: zero length dir at offset "))
            and _ = _cogent_log_u64 (dbg_EXT2_DIR_WRITE, offset)
            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, " BUT dir_end IS ")
            and _ = _cogent_log_u64 (dbg_EXT2_DIR_WRITE, dir_end)
            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, " and offset_limit is ")
            and _ = _cogent_log_u64 (dbg_EXT2_DIR_WRITE, offset_limit)
            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")
            in ((ex, state, offset, new_offset), Stop eIO)
        else
            let matched_name = ext2_match (name, dirent) !dirent
            in if matched_name then
                let ex = destroy_Ext2DirEnt (ex, dirent)
                in ((ex, state, offset, new_offset), Stop eExist)
            else
                -- name_len should be smallest_ondisk_reclen
                let smallest_ondisk_reclen = ext2_dir_rec_len (upcast dirent.name_length) !dirent
                and ondisk_reclen = ext2_rec_len_from_disk (dirent.record_length) !dirent
                and de_ino = dirent.inode !dirent
                in if de_ino == 0 && ondisk_reclen >= required_reclen then
                    let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("check_dirent_fits: consuming whole, empty dirent\n"))
                    -- just consume it completely, empty dirent
                    in ((ex, state, offset, new_offset), Return (smallest_ondisk_reclen, ondisk_reclen, dirent))
                else
                    if ondisk_reclen >= smallest_ondisk_reclen + required_reclen then
                        -- we have space inside this dirent, split it up
                        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("check_dirent_fits: going to split\n\n"))
                        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("current ondisk reclen = "))
                        and _ = _cogent_log_u16 (dbg_EXT2_DIR_WRITE, ondisk_reclen)
                        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("; smallest on disk reclen for current entry = "))
                        and _ = _cogent_log_u16 (dbg_EXT2_DIR_WRITE, (smallest_ondisk_reclen))
                        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("; required for this entry = "))
                        and _ = _cogent_log_u16 (dbg_EXT2_DIR_WRITE, required_reclen)
                        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")

                        in ((ex, state, offset, new_offset), Return (smallest_ondisk_reclen, ondisk_reclen, dirent))
                    else
                        let ex = destroy_Ext2DirEnt (ex, dirent)
                        --and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("too small\n"))
                        in ((ex, state, offset, new_offset), Next ())


update_dir_and_commit: (ExState, FsState, OSPage, OSPageBuffer, VfsInode, U64, U16) -> RR (ExState, FsState, VfsInode) () ()
update_dir_and_commit (ex, state, page, kaddr, inode, offset, rec_len) =
    -- commit the page
    let (ex, state, page) = ext2_commit_chunk (ex, state, page, offset, upcast rec_len)

    -- update mtime, ctime
    and (ex, now) = os_get_current_time ex
    and inode = vfs_inode_set_mtime  (inode, now)
    and inode = vfs_inode_set_ctime  (inode, now)

    -- mark dirty for writing
    and (ex, inode) = vfs_inode_mark_dirty (ex, inode)

    -- put the page
    and page' = ospage_unmap (page, kaddr)
    and _ = ospagecache_release page' -- why do we not need to unlock??? BECAUSE COMMIT DOES

    in ((ex, state, inode), Success ())

type FindSpaceAcc = (ExState, FsState, VfsInode)
type FindSpaceObsv = (U16, CString!, VfsInode!)

get_page_and_find_space: Seq64_body FindSpaceAcc FindSpaceObsv U32
get_page_and_find_space (r {acc = (ex, state, dir_inode), obsv = (rec_len, name, item_inode), idx = n}) = 
    let offset:U64 = 0

    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "get_page_and_find_space: checking page ")
    and _ = _cogent_log_u64 (dbg_EXT2_DIR_WRITE, n)
    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")

    in ospagecache_read (vfs_inode_get_mapping (dir_inode), n) !dir_inode
    | Success (page) ->
        let page_locked = ospage_lock page
        in ospage_map (page_locked)
        | Success (page_locked, kaddr) ->
            let (ex, res) = deserialise_Ext2DirEnt2 (ex, kaddr, u64_to_u32 offset) !kaddr  -- XXX: downcast
            in res
            | Success (dirent, _) ->
                let dir_end:U64 = ext2_last_byte (dir_inode, n) !dir_inode  -- dir_end
                and offset_limit:U64 = os_PAGE_CACHE_SIZE - upcast rec_len  -- kaddr
                and next_offset = upcast (ext2_rec_len_from_disk dirent.record_length) !dirent

                -- inner while loop line 520
                and ((ex, state, offset, offset'), res) = iterate_do
                        [Ext2DirEnt, FittingDirentsInPageRet, U32,
                            FittingDirentsInPageAcc, FittingDirentsInPageObsv]
                (#{ -- emit runs first with init, then get_next
                    init = dirent,
                    gen = get_next_dirent_from_page3,
                    cons = check_dirent_fits,
                    acc = (ex, state, offset, next_offset),
                    obsv = (name, dir_end, rec_len, kaddr, offset_limit)
                    }) !kaddr 
                in res
                | Stop err ->
                    -- needed to stop (either dir_emit told us to break or ran off page)
                    let page_locked = ospage_unmap (page_locked, kaddr)
                    and page = ospage_unlock (page_locked)
                    and _ = ospagecache_release page

                    in if err == 0 then 
                        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("get_page_and_find_space: end of this page\n"))
                        in ((ex, state, dir_inode), Iterate ())
                    else
                        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("get_page_and_find_space: failed to get dirent with error "))
                        and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, (err))
                        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("\n"))
                        in ((ex, state, dir_inode), Break err)
                | Return (compressed_reclen, current_reclen, de) ->
                    -- found the place to put it
                    let page_pos = (n << os_PAGE_CACHE_SHIFT) + offset

                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "get_page_and_find_space: going to place dirent in page ")
                    and _ = _cogent_log_u64 (dbg_EXT2_DIR_WRITE, (n))
                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, " at offset ")
                    and _ = _cogent_log_u64 (dbg_EXT2_DIR_WRITE, offset)
                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, " (byte offset ")
                    and _ = _cogent_log_u64 (dbg_EXT2_DIR_WRITE, page_pos)
                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ")\n")

                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "get_page_and_find_space: have compressed_reclen=")
                    and _ = _cogent_log_u16 (dbg_EXT2_DIR_WRITE, compressed_reclen)
                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, " current_reclen=")
                    and _ = _cogent_log_u16 (dbg_EXT2_DIR_WRITE, current_reclen)
                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")

                    -- we found the place to put the dirent
                    and ((ex, state, page_locked), res) = ext2_prepare_chunk (ex, state, page_locked, page_pos, upcast current_reclen)
                    in res
                    | Success () ->
                        let had_ino = de.inode /= 0 !de
                        in if had_ino then
                            -- we found a dirent big enough to hold its own data
                            -- and our own
                            --
                            -- shrink the old one, make the new one the min size we need
                            -- for the name/ino/etc
                            let new_reclen = current_reclen - compressed_reclen
                            and de = de { record_length = compressed_reclen }

                            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "get_page_and_find_space: found an existing dirent with enough spare space\n")

                            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "get_page_and_find_space: serialising old dirent at page offset ")
                            and _ = _cogent_log_u64 (dbg_EXT2_DIR_WRITE, offset)
                            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, " with reclen ")
                            and _ = _cogent_log_u16 (dbg_EXT2_DIR_WRITE, compressed_reclen)
                            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, " and namelen ")
                            and _ = _cogent_log_u8 (dbg_EXT2_DIR_WRITE, de.name_length) !de
                            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")

                            -- write out old de to buffer to update it
                            and ((ex, kaddr, _), res) = serialise_Ext2DirEnt (ex, de, kaddr, u64_to_u32 offset) !de
                            and ex = destroy_Ext2DirEnt (ex, de)
                            in res
                            | Success () ->
                                -- and fill in and write new de
                                let name_len = u32_to_u8 (wordarray_length [U8] name)
                                and new_offset = u64_to_u32 (offset + upcast compressed_reclen) -- fixme: cast

                                and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "get_page_and_find_space: serialising new dirent at page offset ")
                                and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, new_offset)
                                and _ = _cogent_log (dbg_EXT2_DIR_WRITE, " with reclen ")
                                and _ = _cogent_log_u16 (dbg_EXT2_DIR_WRITE, new_reclen)
                                and _ = _cogent_log (dbg_EXT2_DIR_WRITE, " and namelen ")
                                and _ = _cogent_log_u8 (dbg_EXT2_DIR_WRITE, name_len)
				and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "INO = ")
				and _ =  _cogent_log_u32 (dbg_EXT2_DIR_WRITE, vfs_inode_get_ino (item_inode)) !item_inode
                                and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")

                                and ((ex, kaddr, _), res) = serialise_Ext2DirEnt2 (ex, item_inode, new_reclen, name, name_len, kaddr, new_offset)
                                in res
                                | Success () ->
                                    -- cleanup
                                    let ((ex, state, dir_inode), res) = update_dir_and_commit (ex, state, page_locked, kaddr, dir_inode, page_pos, current_reclen)
                                    in res
                                    | Success () ->
                                        ((ex, state, dir_inode), Break 0)
                                    | Error () ->
                                        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("failed to serialise new de\n"))
                                        in ((ex, state, dir_inode), Break eIO)
                                | Error () ->
                                    let page_locked = ospage_unmap (page_locked, kaddr)
                                    and page = ospage_unlock (page_locked)
                                    and _ = ospagecache_release (page)

                                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("failed to serialise new de\n"))
                                    in ((ex, state, dir_inode), Break eIO)
                            | Error () ->
                                let page_locked = ospage_unmap (page_locked, kaddr)
                                and page = ospage_unlock (page_locked)
                                and _ = ospagecache_release (page)

                                and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("failed to write updated de\n"))
                                in ((ex, state, dir_inode), Break eIO)
                        else
                            -- just fill in and write found de space
                            --let de = de { name, inode = vfs_inode_get_ino (item_inode) }
                            --and ((ex, kaddr, _), res) = serialise_Ext2DirEnt (ex, de, kaddr, offset) !de
                            let name_len = u32_to_u8 (wordarray_length [U8] (name))

                            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "get_page_and_find_space: serialising into location above (should be free)\n")

                            and ((ex, kaddr, _), res) = serialise_Ext2DirEnt2 (ex, item_inode, current_reclen, name, name_len, kaddr, u64_to_u32 (offset)) !de -- fixme: cast
                            and ex = destroy_Ext2DirEnt (ex, de)
                            in res
                            | Success () ->
                                -- cleanup
                                let ((ex, state, dir_inode), res) = update_dir_and_commit (ex, state, page_locked, kaddr, dir_inode, page_pos, current_reclen)
                                in res
                                | Success () ->
                                    ((ex, state, dir_inode), Break 0)
                                | Error () ->
                                    ((ex, state, dir_inode), Break eIO)
                            | Error () ->
                                let page_locked = ospage_unmap (page_locked, kaddr)
                                and page = ospage_unlock (page_locked)
                                and _ = ospagecache_release (page)

                                and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("get_page_and_find_space: failed to serialise new dirent\n"))
                                in ((ex, state, dir_inode), Break eIO)
                    | Error err ->
                        let ex = destroy_Ext2DirEnt (ex, de)

                        and page_locked = ospage_unmap (page_locked, kaddr)
                        and page = ospage_unlock (page_locked)
                        and _ = ospagecache_release (page)

                        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("get_page_and_find_space: failed to begin write\n"))
                        in ((ex, state, dir_inode), Break err)
            | Error () ->
                let page_locked = ospage_unmap (page_locked, kaddr)
                and page = ospage_unlock (page_locked)
                and _ = ospagecache_release (page)

                and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("get_page_and_find_space: failed to deser\n"))
                in ((ex, state, dir_inode), Break eIO)
        | Error (page_locked) ->
            let page = ospage_unlock (page_locked)
            and _ = ospagecache_release (page)
            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("get_page_and_find_space: failed to map\n"))
            in ((ex, state, dir_inode), Break eIO)
    | Error () ->
        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("get_page_and_find_space: failed to get page\n"))
        in ((ex, state, dir_inode), Break eIO)

-- ext2_add_link + ext2_add_nondir
-- YOU MUST, however, unlock inode yourself!
ext2_dir_add: (ExState, FsState, VfsInode, VfsInode!, CString!) -> RR (ExState, FsState, VfsInode) () (U32)
ext2_dir_add (ex, state, dir_inode, inode, name) =
    let name_len = wordarray_length[U8] (name)
    and chunk_size = const_blockSize
    and reclen = ext2_dir_rec_len (u32_to_u16 (name_len)) -- FIXME: downcast
    and npages = ext2_dir_pages (dir_inode) !dir_inode
    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_add ")
    and _ = if (_COGENT_LOG_LEVEL .&. dbg_EXT2_DIR_WRITE) /= 0 then wordarray_print name else ()
    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")
    and ((ex, state, dir_inode), res) = seq64[FindSpaceAcc, FindSpaceObsv, U32]
    #{  frm  = 0
     ,  to   = npages + 1
     ,  step = 1
     ,  f    = get_page_and_find_space
     ,  acc  = (ex, state, dir_inode)
     ,  obsv = (reclen, name, inode) }
    in res
    | Break err ->
        if err == 0 then
            ((ex, state, dir_inode), Success ())
        else
            let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_add: had error ")
            and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, err)
            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")
            in ((ex, state, dir_inode), Error err)
    | Iterate () ->
        -- if this happens, on disk layout is inconsistent
        -- i.e. we said we had spare space but we lied
        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_add: disk layout inconsistent\n")
        in ((ex, state, dir_inode), Error eInval)

------------------------------------------------------------------------------
-- removing from directory
------------------------------------------------------------------------------

ext2_dir_remove_from_page_finish: (ExState, FsState, VfsInode, OSPage, OSPageBuffer, U32, U32, U32) -> RR (ExState, FsState, VfsInode) () U32
ext2_dir_remove_from_page_finish (ex, state, inode, page_locked, pagebuf, current_offset, from_offset, to_offset) =
	   -- serialise current de's inode to 0
   let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("ext2_dir_remov_from_page_finish: current offset: "))
       and _ = _cogent_log_u32(dbg_EXT2_DIR_WRITE, current_offset)
       and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")
       in    ospagebuffer_serialise_Ple32 (pagebuf, current_offset, 0)
    | Success (pagebuf, _) =>
        let (ex, state, page_locked) = ext2_commit_chunk (ex, state, page_locked, upcast from_offset, to_offset - from_offset)

        and (ex, now) = os_get_current_time (ex)
        and inode = vfs_inode_set_ctime (inode, now)
        and inode = vfs_inode_set_mtime (inode, now)

        and (ex, inode) = vfs_inode_mark_dirty (ex, inode)

        and page = ospage_unlock (page_locked)
        and page = ospage_unmap (page, pagebuf)
        and _ = ospagecache_release (page)
        in ((ex, state, inode), Success ())
    | Error (pagebuf) ->
        let page = ospage_unlock (page_locked)
        and page = ospage_unmap (page, pagebuf)
        and _ = ospagecache_release (page)
        in ((ex, state, inode), Error eIO)

ext2_dir_remove_from_page2: (ExState, FsState, VfsInode, OSPage, OSPageBuffer, U32, U32, U32, Option Ext2DirEnt) -> RR (ExState, FsState, VfsInode) () U32
ext2_dir_remove_from_page2 (ex, state, inode, page, pagebuf, current_offset, from_offset, to_offset, maybe_prev) =
   let
       _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_remove_from_page2: from_offset: ")
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, from_offset) !from_offset
    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ", to_offset = ")
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, to_offset) !to_offset
    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")

    and page_locked = ospage_lock page
    and ((ex, state, page_locked), res) = ext2_prepare_chunk (ex, state, page_locked, upcast from_offset, to_offset - from_offset)
    in res
    | Success () =>
        -- serialise onto previous dirent
        maybe_prev
        | Some prev_de ->
            let ex = destroy_Ext2DirEnt (ex, prev_de)
            in ospagebuffer_serialise_Ple16 (pagebuf, from_offset + 4, u32_to_u16 (to_offset - from_offset)) -- fixme; cast?
            | Success (pagebuf, _) =>
                ext2_dir_remove_from_page_finish (ex, state, inode, page_locked, pagebuf, current_offset, from_offset, to_offset)
            | Error (pagebuf) ->
                let page = ospage_unlock (page_locked)
                and page = ospage_unmap (page, pagebuf)
                and _ = ospagecache_release (page)
                in ((ex, state, inode), Error eIO)
        | None () ->
            ext2_dir_remove_from_page_finish (ex, state, inode, page_locked, pagebuf, current_offset, from_offset, to_offset)
    | Error err ->
        let ex = dispose_existing_dirent (ex, maybe_prev)

        and page = ospage_unlock (page_locked)
        and page = ospage_unmap (page, pagebuf)
        and _ = ospagecache_release (page)
        in ((ex, state, inode), Error err)

find_prev_dirent: Seq32_body (ExState, Option Ext2DirEnt, U32) (U32, OSPageBuffer!) U32
find_prev_dirent #{ acc = (ex, maybe_de, from_offset), obsv = (current_offset, pagebuf), idx } =
    if from_offset < current_offset then
        -- deser at from_offset
        let (ex, res) = deserialise_Ext2DirEnt2 (ex, pagebuf, from_offset)
        in res
        | Success (de, _) =>
            let was_valid = de.record_length /= 0 !de
            and ex = dispose_existing_dirent (ex, maybe_de)
            in was_valid
            | True =>
                let reclen = ext2_rec_len_from_disk de.record_length !de
                in ((ex, Some de, from_offset + upcast reclen), Iterate)
            | _ ->
                let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("had zero-length dir\n"))
                in ((ex, Some de, from_offset), Break eIO)
        | Error () ->
            let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("failed to deser dirent\n"))
            in ((ex, maybe_de, from_offset), Break eIO)
    else
        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("from_offset >= current_offset; breaking\n"))
        in ((ex, maybe_de, from_offset), Break 0)

ext2_dir_remove_from_page: (ExState, FsState, VfsInode, Ext2DirEnt, OSPage, OSPageBuffer, U32) -> RR (ExState, FsState, VfsInode) () U32
ext2_dir_remove_from_page (ex, state, inode, de, page, pagebuf, current_offset) =
    let chunk_size = const_blockSize

    and from_offset = current_offset .&. (complement (chunk_size - 1)) -- get to a block previous of the dirent (since they can expand no larger than this)
    and to_offset =  ospagebuffer_deserialise_Ple16 (pagebuf, current_offset + 4) !pagebuf
                 | Success (val, _) -> current_offset + upcast val
                 | Error () -> 0

    -- start at from_offset, and work out way forwards until we get to current_offset
    -- to try and find the closest dirent BEFORE us

    and ex = destroy_Ext2DirEnt (ex, de)

    and ((ex, maybe_prev, from_offset), res) = seq32 [(ExState, Option Ext2DirEnt, U32), (U32, OSPageBuffer!), U32] #{
        frm   = 0,
        to    = to_offset, 
        step  = 1,
        f     = find_prev_dirent,
        acc   = (ex, None (), from_offset),
        obsv  = (current_offset, pagebuf)
    } !pagebuf

    in res
    | Break maybe_err ->
        if maybe_err == 0 then
            -- okay, hit dirent while trying to find previous
            ext2_dir_remove_from_page2 (ex, state, inode, page, pagebuf, current_offset, from_offset, to_offset, maybe_prev)
        else
            -- cleanup
            let ex = dispose_existing_dirent (ex, maybe_prev)

            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("find_prev_dirent raised error\n"))

            and page = ospage_unmap (page, pagebuf)
            and _ = ospagecache_release (page)
            in ((ex, state, inode), Error maybe_err)
    | Iterate () ->
        ext2_dir_remove_from_page2 (ex, state, inode, page, pagebuf, current_offset, from_offset, to_offset, maybe_prev)

-- wrapper code MUST do ihold (inode) because in success case we put in the dcache
fsop_dir_link: (ExState, FsState, VfsInode, VfsInode, CString!) -> RR (ExState, FsState, VfsInode, VfsInode) () U32
fsop_dir_link (ex, state, parent, inode, name) =
    let (ex, now) = os_get_current_time (ex)

    and inode = vfs_inode_set_ctime (inode, now)
    and inode = vfs_inode_inc_nlink (inode)

    and ((ex, state, parent), res) = ext2_dir_add (ex, state, parent, inode, name) !inode
    in res
    | Success () =>
        ((ex, state, parent, inode), Success ())
    | Error (err) ->
        let inode = vfs_inode_dec_nlink (inode) -- put link count back
        in ((ex, state, parent, inode), Error err)

-- ex, state, parent, inode, name
fsop_dir_unlink: (ExState, FsState, VfsInode, VfsInode, CString!) -> RR (ExState, FsState, VfsInode, VfsInode) () U32
fsop_dir_unlink (ex, state, parent, inode, name) =
    let ((ex, state, parent), res) = ext2_find_entry (ex, state, parent, name)
    in res
    | Success (de, page, pagebuf, current_offset) ->
        -- now we have the entry, delete it
        let ((ex, state, parent), res) = ext2_dir_remove_from_page (ex, state, parent, de, page, pagebuf, current_offset)
        in res
        | Success () =>
            let inode = vfs_inode_set_ctime (inode, vfs_inode_get_ctime (parent)) !parent
            and inode = vfs_inode_dec_nlink (inode)
            in ((ex, state, parent, inode), Success ())
        | Error e ->
            let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("remove from page failed\n"))
            in ((ex, state, parent, inode), Error e)
    | Error e ->
        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("find entry failed\n"))
        in ((ex, state, parent, inode), Error e)


------------------------------------------------------------------------------
-- new file
------------------------------------------------------------------------------

-- wrapper should should dirty inode, setup inode ops
fsop_dir_create: (ExState, FsState, VfsInode, CString!, VfsMode) -> RR (ExState, FsState, VfsInode) VfsInode U32
fsop_dir_create (ex, state, parent_inode, name, mode) =
    let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "fsop_dir_create: want to create with mode ")
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, mode)
    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")
    and ((ex, state), res) = ext2_inode_create (ex, state, parent_inode, mode) !parent_inode
    in res
    | Success new_inode ->
        let new_inode = vfs_inode_set_ops (new_inode, ext2_reg_inode_ops)
        and new_inode = vfs_inode_set_fileops (new_inode, ext2_reg_file_ops)

        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "fsop_dir_create: created new inode okay; adding to dir\n")
        and ((ex, state, parent_inode), res) = ext2_dir_add (ex, state, parent_inode, new_inode, name) !new_inode
        in res
        | Success () ->
            let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "fsop_dir_create: success!\n")
            and new_inode = vfs_inode_unlock_new new_inode

            in ((ex, state, parent_inode), Success new_inode)
        | Error err ->
            let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "fsop_dir_create: adding new inode to dir failed\n")

            and ex = vfs_inode_bad #{ex, inode = new_inode}
            in ((ex, state, parent_inode), Error err)
    | Error err ->
        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "fsop_dir_create: inode creation failed\n")
        in ((ex, state, parent_inode), Error err)

------------------------------------------------------------------------------
-- rmdir/mkdir
------------------------------------------------------------------------------

-- puts . and .. in new directory
-- ex, dir, parent (for .. link)
ext2_dir_make_empty: (ExState, FsState, VfsInode, VfsInode!) -> Result (ExState, FsState, VfsInode) (ExState, FsState, VfsInode)
ext2_dir_make_empty (ex, state, dir_inode, parent_inode) = 
    wordarray_create_nz[U8] (ex, 4)
    | Success (ex, namestr) =>
        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_make_empty: getting page #0 for dir inode ")
        and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, (vfs_inode_get_ino (dir_inode))) !dir_inode
        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")

        in ospagecache_grab (vfs_inode_get_mapping (dir_inode), 0) !dir_inode
        | Success (page) =>
            let chunk_size = const_blockSize

            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_make_empty: preparing chunk on page from 0 to ")
            and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, chunk_size)
            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, " (chunk size)\n")

            and ((ex, state, page), res) = ext2_prepare_chunk (ex, state, page, 0, chunk_size)
            in res
            | Success () =>
                let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_make_empty: success, mapping page...\n")
                in ospage_map (page)
                | Success (page, kaddr) =>
                    let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_make_empty: success, setting chunk to 0...\n")

                    -- FIXME: should wrap reclen in ext2_rec_len_from_disk for safety
                    -- FIXME: should set dirent type (nahhh.. )
                    and kaddr = ospagebuffer_memset (kaddr, 0, 0, chunk_size)

                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_make_empty: serialising '.' dirent...\n")
                    and namestr = wordarray_put2 [U8] #{ arr = namestr, idx = 0, val = '.' } -- .
                    and namestr = wordarray_put2 [U8] #{ arr = namestr, idx = 1, val = '\0' } -- ..
                    and ((ex, kaddr, _), res) = serialise_Ext2DirEnt2 (ex, dir_inode, ext2_dir_rec_len (1), namestr, 1, kaddr, 0) !dir_inode !namestr

                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_make_empty: serialising '..' dirent...\n")
                    and namestr = wordarray_put2 [U8] #{ arr = namestr, idx = 1, val = '.' } -- ..
                    and namestr = wordarray_put2 [U8] #{ arr = namestr, idx = 2, val = '\0' } 
                    and ((ex, kaddr, _), res) = serialise_Ext2DirEnt2 (ex, parent_inode, u32_to_u16 chunk_size - ext2_dir_rec_len 1, namestr, 2, kaddr, upcast (ext2_dir_rec_len 1)) !dir_inode !namestr

                    and ex = wordarray_free [U8] (ex, namestr)

                    -- commit, unlock and release
                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_make_empty: committing chunk...\n")
                    and (ex, state, page) = ext2_commit_chunk (ex, state, page, 0, chunk_size)
                    
                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_make_empty: unmapping page\n")
                    and page = ospage_unmap (page, kaddr)

                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_make_empty: releasing page\n")
                    and _ = ospagecache_release (page)

                    in Success (ex, state, dir_inode)
                | Error (page) ->
                    let ex = wordarray_free [U8] (ex, namestr)

                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_make_empty: ERROR: map failed\n")

                    -- unlock and release
                    and page = ospage_unlock (page)
                    and _ = ospagecache_release (page)

                    in Error (ex, state, dir_inode)
            | Error err ->
                let ex = wordarray_free [U8] (ex, namestr)

                and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_make_empty: ERROR: write_prepare failed with ")
                and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, err)
                and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")

                -- unlock and release
                and page = ospage_unlock page
                and _ = ospagecache_release page

                in Error (ex, state, dir_inode)
        | Error () ->
            let ex = wordarray_free [U8] (ex, namestr)
            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "ext2_dir_make_empty: ERROR: grab page failed\n")

            in Error (ex, state, dir_inode) -- TODO: linux returns ENOMEM, but that seems wrong; ie we have no disk space, create mapping may fail
    | Error ex ->
        Error (ex, state, dir_inode) -- THIS one is ENOMEM (but linux doesn't have this call)

fsop_dir_mkdir: (ExState, FsState, VfsInode, CString!, VfsMode) -> RR (ExState, FsState, VfsInode) VfsInode U32
fsop_dir_mkdir (ex, state, parent_inode, dir_name, mode) =
    let dir_mode = mode .|. s_IFDIR
    and parent_inode = vfs_inode_inc_nlink parent_inode -- child now points to parent
    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("fsop_dir_mkdir: creating inode\n"))
    and ((ex, state), res) = ext2_inode_create (ex, state, parent_inode, dir_mode) !parent_inode
    in res
    | Success (dir_inode) ->
        let dir_inode = vfs_inode_set_ops (dir_inode, ext2_dir_inode_ops)
        and dir_inode = vfs_inode_set_fileops (dir_inode, ext2_dir_file_ops)

        and dir_inode = vfs_inode_inc_nlink dir_inode       -- parent now points to child

        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")
        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("fsop_dir_mkdir: have inode, putting default dirents\n"))

        in ext2_dir_make_empty (ex, state, dir_inode, parent_inode) !parent_inode  -- put . and .. in new directory
        | Success (ex, state, dir_inode) ->
            let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")
            and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("fsop_dir_mkdir: adding to parent\n"))
            and ((ex, state, parent_inode), res) = ext2_dir_add (ex, state, parent_inode, dir_inode, dir_name) !dir_inode
            in res
            | Success ->
                -- unlock
                let dir_inode = vfs_inode_unlock_new dir_inode

                and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")
                and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("fsop_dir_mkdir: done + unlocked!\n"))
                in ((ex, state, parent_inode), Success dir_inode)
            | Error err ->
                let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("fsop_dir_mkdir: ERROR: could not add to parent\n"))
                and dir_inode = vfs_inode_dec_nlink dir_inode       -- undo
                and ex = vfs_inode_bad #{ex, inode = dir_inode}
                and parent_inode = vfs_inode_dec_nlink parent_inode -- undo
                in ((ex, state, parent_inode), Error err)
        | Error (ex, state, dir_inode) ->
            let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("fsop_dir_mkdir: ERROR: could not make empty\n"))
            and dir_inode = vfs_inode_dec_nlink dir_inode       -- undo
            and ex = vfs_inode_bad #{ex, inode = dir_inode}
            and parent_inode = vfs_inode_dec_nlink parent_inode -- undo
            in ((ex, state, parent_inode), Error eIO) -- FIXME: error code?
    | Error err ->
        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("fsop_dir_mkdir: ERROR: could not allocate inode\n"))
        and parent_inode = vfs_inode_dec_nlink parent_inode -- undo
        in ((ex, state, parent_inode), Error err)

-- and decrement the link count on it and the parent dir
fsop_dir_rmdir: (ExState, FsState, VfsInode, VfsInode, CString!) -> RR (ExState, FsState, VfsInode, VfsInode) () U32
fsop_dir_rmdir (ex, state, parent_inode, dir_inode, name) = 
    let ((ex, state), res) = ext2_dir_is_empty (ex, state, dir_inode) !dir_inode
    in res
    | Success was_empty ->
        if was_empty then
            let ((ex, state, parent_inode, dir_inode), res) = fsop_dir_unlink (ex, state, parent_inode, dir_inode, name)
            in res
            | Success =>
                let dir_inode = vfs_inode_set_size (dir_inode, 0)
                and dir_inode = vfs_inode_dec_nlink (dir_inode)

                and parent_inode = vfs_inode_dec_nlink (parent_inode)
                -- don't need to dirty since dec_nlink also dirties inode

                in ((ex, state, parent_inode, dir_inode), Success ())
            | Error err ->
                ((ex, state, parent_inode, dir_inode), Error err)
        else
            ((ex, state, parent_inode, dir_inode), Error eNotEmpty)
    | Error err ->
        ((ex, state, parent_inode, dir_inode), Error err)

------------------------------------------------------------------------------
-- rename
------------------------------------------------------------------------------

ext2_remove_from_pagectx: (ExState, FsState, VfsInode, Ext2DirEnt, OSPageContext) -> RR (ExState, FsState, VfsInode) () U32
ext2_remove_from_pagectx (ex, state, parent, de, ctx) =
    let ctx_t {page, buf, pos} = ctx
    in ext2_dir_remove_from_page (ex, state, parent, de, page, buf, pos)

-- second half of a rename operation: removing the old entry
fsop_rename_remove_old_file: (ExState, FsState, VfsRenameContext, Ext2DirEnt, OSPageContext) -> RR (ExState, FsState, VfsRenameContext) () (U32)
fsop_rename_remove_old_file (ex, state, rename_ctx, src_dirent, src_dir_pagectx) = 
    -- FIXME: update ctime
    let rename_ctx_t {src_inode} = rename_ctx
    and ((ex, state, src_inode), res) = ext2_remove_from_pagectx (ex, state, src_inode, src_dirent, src_dir_pagectx)
    and (ex, src_inode) = vfs_inode_mark_dirty (ex, src_inode)
    in res
    | Success ->
        -- cool, all done
        let rename_ctx = rename_ctx_t {src_inode}
        in ((ex, state, rename_ctx), Success ())
    | Error err ->
        let rename_ctx = rename_ctx_t {src_inode}
        in ((ex, state, rename_ctx), Error err)

fsop_rename_remove_old_dir: (ExState, FsState, VfsRenameContext, Ext2DirEnt, Ext2DirEnt, OSPageContext, OSPageContext) -> RR (ExState, FsState, VfsRenameContext) () (U32)
fsop_rename_remove_old_dir (ex, state, rename_ctx, src_dirent, src_dotdot_dirent, src_dir_pagectx, src_dotdot_pagectx) =
    let ((ex, state, rename_ctx), res) = fsop_rename_remove_old_file (ex, state, rename_ctx, src_dirent, src_dir_pagectx)
    in res
    | Success ->
        let rename_ctx_t {dirs, src_inode} = rename_ctx
        in dirs
        | SrcDest different ->
            let different_t { src_dir, dest_dir } = different
            and src_dir = vfs_inode_dec_nlink (src_dir)
            and (ex, src_dir) = vfs_inode_mark_dirty (ex, src_dir)

            -- fix .. in moved dir to point to new parent
            and ((ex, state, dest_dir, src_inode), res) = ext2_dir_update (ex, state, src_inode, src_dotdot_dirent, dest_dir, src_dotdot_pagectx) !src_dotdot_dirent
            in res
            | Success ->
                let different = different_t { src_dir, dest_dir }
                and rename_ctx = rename_ctx_t {dirs = SrcDest different, src_inode}

                and ex = destroy_Ext2DirEnt (ex, src_dotdot_dirent)
                in ((ex, state, rename_ctx), Success)
            | Error err ->
                let different = different_t { src_dir, dest_dir }
                and rename_ctx = rename_ctx_t {dirs = SrcDest different, src_inode}

                and ex = destroy_Ext2DirEnt (ex, src_dotdot_dirent)
                in ((ex, state, rename_ctx), Error err)
        | Dest dest_dir ->
            let dest_dir = vfs_inode_dec_nlink (dest_dir) --- TODO: cancel out with the other inc_nlink
            and (ex, dest_dir) = vfs_inode_mark_dirty (ex, dest_dir)

            -- moved to same dir, still okay
            and _ = ospagectx_destroy (src_dotdot_pagectx)
            and rename_ctx = rename_ctx_t {dirs = Dest dest_dir, src_inode}
            and ex = destroy_Ext2DirEnt (ex, src_dotdot_dirent)
            in ((ex, state, rename_ctx), Success ())
    | Error err ->
        let ex = destroy_Ext2DirEnt (ex, src_dotdot_dirent)
        and _ = ospagectx_destroy (src_dotdot_pagectx)
        in ((ex, state, rename_ctx), Error (err))

fsop_rename_file_existing2: (ExState, FsState, VfsRenameContext take (dest_inode, dirs), Ext2DirEnt, VfsInode, Ext2DirEnt, VfsRenameDirs, R () U32, OSPageContext) -> RR (ExState, FsState, VfsRenameContext) () U32
fsop_rename_file_existing2 (ex, state, rename_ctx_t, src_dirent, dest_inode, dest_dirent, dirs, res, src_dir_pagectx) =
    res
    | Success () ->
        let dest_inode = vfs_inode_dec_nlink (dest_inode)
        -- FIXME: set dest_inode.i_ctime = CURRENT_TIME_SEC
        and rename_ctx = rename_ctx_t { dest_inode = Some dest_inode, dirs }
        and ex = destroy_Ext2DirEnt (ex, dest_dirent)

        -- and go remove the old entry
        in fsop_rename_remove_old_file (ex, state, rename_ctx, src_dirent, src_dir_pagectx)
    | Error (err) ->
        let rename_ctx = rename_ctx_t { dest_inode = Some dest_inode, dirs }
        and _  = ospagectx_destroy (src_dir_pagectx)
        and ex = destroy_Ext2DirEnt (ex, dest_dirent)
        and ex = destroy_Ext2DirEnt (ex, src_dirent)
        in ((ex, state, rename_ctx), Error err)

fsop_rename_file_existing: (ExState, FsState, VfsRenameContext take (dest_inode, dirs), Ext2DirEnt, VfsInode, VfsRenameDirs, OSPageContext) -> RR (ExState, FsState, VfsRenameContext) () U32
fsop_rename_file_existing (ex, state, rename_ctx_t, src_dirent, dest_inode, dirs, src_dir_pagectx) =
    -- existing inode, just update the existing dir entry to point to the right inode, first decrementing target link count

    let ((ex, state), res) = ext2_find_entry_bang (ex, state, vfs_rename_get_dest_dir2 dirs, rename_ctx_t.dest_name) !dirs !rename_ctx_t
    in res
    | Success (dest_dirent, page, pagebuf, offset) =>
        let dest_pagectx = #{page, buf = pagebuf, pos = offset}
        and rename_ctx_t { src_inode } = rename_ctx_t

        in dirs
        | SrcDest both ->
            let both_t { dest_dir } = both 
            -- also updates ctime, mtime, etc
            and ((ex, state, dest_dir, src_inode), res) = ext2_dir_update (ex, state, dest_dir, dest_dirent, src_inode, dest_pagectx) !dest_dirent
            and both = both_t { dest_dir }

            and rename_ctx_t = rename_ctx_t { src_inode }
            in fsop_rename_file_existing2 (ex, state, rename_ctx_t, src_dirent, dest_inode, dest_dirent, SrcDest both, res, src_dir_pagectx)
        | Dest dest_dir ->
            -- also updates ctime, mtime, etc
            let ((ex, state, dest_dir, src_inode), res) = ext2_dir_update (ex, state, dest_dir, dest_dirent, src_inode, dest_pagectx) !dest_dirent

            and rename_ctx_t = rename_ctx_t { src_inode }
            in fsop_rename_file_existing2 (ex, state, rename_ctx_t, src_dirent, dest_inode, dest_dirent, Dest dest_dir, res, src_dir_pagectx)
    | Error (err) ->
        let rename_ctx = rename_ctx_t { dest_inode = Some dest_inode, dirs }
        and ex = destroy_Ext2DirEnt (ex, src_dirent)
        and _  = ospagectx_destroy (src_dir_pagectx)
        in ((ex, state, rename_ctx), Error err)

-- src_dirent may have changed in-buffer, need to re-read.
fsop_rename_file2: (ExState, FsState, VfsRenameContext take (dest_inode, dirs), Ext2DirEnt, VfsRenameDirs, R () U32, OSPageContext) -> RR (ExState, FsState, VfsRenameContext) () (U32)
fsop_rename_file2 (ex, state, rename_ctx_t, src_dirent, dirs, res, src_dir_pagectx) =
    res
    | Success () ->
        -- go remove the old entry
        let rename_ctx_t = rename_ctx_t { dest_inode = None (), dirs }       
        in fsop_rename_remove_old_file (ex, state, rename_ctx_t, src_dirent, src_dir_pagectx)
    | Error (err) ->
        let rename_ctx = rename_ctx_t { dest_inode = None (), dirs }
        and _  = ospagectx_destroy (src_dir_pagectx)
        and ex = destroy_Ext2DirEnt (ex, src_dirent)
        in ((ex, state, rename_ctx), Error err)

-- first half of a rename operation: add the new entry
-- no existing inode, just add link to dest
fsop_rename_file: (ExState, FsState, VfsRenameContext, Ext2DirEnt, OSPageContext) -> RR (ExState, FsState, VfsRenameContext) () U32
fsop_rename_file (ex, state, rename_ctx, src_dirent, src_dir_pagectx) =
    let rename_ctx_t { dest_inode = maybe_dest_inode, dirs } = rename_ctx
    in maybe_dest_inode
    | Some dest_inode ->
        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("had dest inode, renaming over existing link\n"))
        in fsop_rename_file_existing (ex, state, rename_ctx_t, src_dirent, dest_inode, dirs, src_dir_pagectx)
    | _ ->
        -- just add a new entry pointing to the source inode
        let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("no dest inode, going to add a new one with the new name first\n"))

        and rename_ctx_t { src_inode } = rename_ctx_t
        in dirs
        | SrcDest both ->
            let both_t { dest_dir } = both 
            and ((ex, state, dest_dir), res) = ext2_dir_add (ex, state, dest_dir, src_inode, rename_ctx_t.dest_name) !src_inode !rename_ctx_t
            and both = both_t { dest_dir }

            and rename_ctx_t = rename_ctx_t { src_inode }
            in fsop_rename_file2 (ex, state, rename_ctx_t, src_dirent, SrcDest both, res, src_dir_pagectx)
        | Dest dest_dir ->
            let ((ex, state, dest_dir), res) = ext2_dir_add (ex, state, dest_dir, src_inode, rename_ctx_t.dest_name) !src_inode !rename_ctx_t

            and rename_ctx_t = rename_ctx_t { src_inode }
            in fsop_rename_file2 (ex, state, rename_ctx_t, src_dirent, Dest dest_dir, res, src_dir_pagectx)

-- this is from the "have new_inode" case: renaming over an existing link
fsop_rename_dir2: (ExState, FsState, VfsRenameContext take (dest_inode, dirs), Ext2DirEnt, Ext2DirEnt, OSPageContext, OSPageContext, VfsInode, Ext2DirEnt, VfsRenameDirs, R () U32) -> RR (ExState, FsState, VfsRenameContext) () (U32)
fsop_rename_dir2 (ex, state, rename_ctx_t, src_dirent, src_dotdot_dirent, src_dir_pagectx, src_dotdot_pagectx, dest_inode, dest_dirent, dirs, res) =
    -- drop nlink on just-replaced inode
    let dest_inode = vfs_inode_set_nlink (dest_inode, 0)
    and (ex, dest_inode) = vfs_inode_mark_dirty (ex, dest_inode)
    in res
    | Success () =>
        let rename_ctx = rename_ctx_t { dirs, dest_inode = Some dest_inode }
        and ex = destroy_Ext2DirEnt (ex, dest_dirent)
        in fsop_rename_remove_old_dir (ex, state, rename_ctx, src_dirent, src_dotdot_dirent, src_dir_pagectx, src_dotdot_pagectx)
    | Error err ->
        let rename_ctx = rename_ctx_t { dirs, dest_inode = Some dest_inode }
        and ex = destroy_Ext2DirEnt (ex, dest_dirent)
        and _  = ospagectx_destroy src_dotdot_pagectx
        and _  = ospagectx_destroy src_dir_pagectx
        and ex = destroy_Ext2DirEnt (ex, src_dotdot_dirent)
        and ex = destroy_Ext2DirEnt (ex, src_dirent)
        in ((ex, state, rename_ctx), Error err)

-- Rename a directory.
--  * args are
--      rename_ctx -- source and destination dirents
--      src_dirent -- original (name,inode) link (Why do we
--                    need this? It should be in rename_ctx)
--      src_dotdot_dirent -- (name, inode)  of directory containing
--                            original link
--      src_dir_pagectx -- (page, buf, offset) of raw (on-disk) (name, inum)
--      src_dotdot_pagectx -- (page, buf, offset) of raw (on-disk) parent's link

fsop_rename_dir: (ExState, FsState, VfsRenameContext, Ext2DirEnt, Ext2DirEnt, OSPageContext, OSPageContext) -> RR (ExState, FsState, VfsRenameContext) () U32
fsop_rename_dir (ex, state, rename_ctx, src_dirent, src_dotdot_dirent, src_dir_pagectx, src_dotdot_pagectx) =
    let rename_ctx_t {dest_inode = maybe_dest_inode, dirs} = rename_ctx
    in maybe_dest_inode
    | Some dest_inode ->
        -- Overwriting an existing link.
        let  _ = _cogent_log (dbg_EXT2_DIR_WRITE, "fsop_rename_dir: checking if destination link is an empty dir...\n")
        and ((ex, state), res) = ext2_dir_is_empty (ex, state, dest_inode) !dest_inode
        and rename_ctx_t { src_inode } = rename_ctx_t
        in res
        | Success was_empty ->
            if was_empty then
                let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "fsop_rename_dir: destination is empty directory, can be overwritten, looking for dest's parent ")
                and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, vfs_inode_get_ino (vfs_rename_get_dest_dir2 (dirs))) !dirs
                and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")

                and ((ex, state), res) = ext2_find_entry_bang (ex, state, vfs_rename_get_dest_dir2 (dirs), rename_ctx_t.dest_name) !dirs !rename_ctx_t
                in res
                | Success (dest_dirent, page, pagebuf, offset) =>
                    let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "fsop_rename_dir: found parent at offset ")
                    and _ = _cogent_log_u32 (dbg_EXT2_DIR_WRITE, offset)
                    and _ = _cogent_log (dbg_EXT2_DIR_WRITE, "\n")

                    and dest_pagectx = #{page, buf = pagebuf, pos = offset}

                    in dirs -- Wherein is the difference between these branches?
                    | SrcDest both ->
                        let both_t { dest_dir } = both
                        and ((ex, state, dest_dir, src_inode), res) = ext2_dir_update (ex, state, dest_dir, dest_dirent, src_inode, dest_pagectx) !dest_dirent

                        and both = both_t { dest_dir }
                        and rename_ctx_t = rename_ctx_t { src_inode }
                        in fsop_rename_dir2 (ex, state, rename_ctx_t, src_dirent, src_dotdot_dirent, src_dir_pagectx, src_dotdot_pagectx, dest_inode, dest_dirent, SrcDest both, res)
                    | Dest dest_dir ->
                        let ((ex, state, dest_dir, src_inode), res) = ext2_dir_update (ex, state, dest_dir, dest_dirent, src_inode, dest_pagectx) !dest_dirent

                        and rename_ctx_t = rename_ctx_t { src_inode }
                        in fsop_rename_dir2 (ex, state, rename_ctx_t, src_dirent, src_dotdot_dirent, src_dir_pagectx, src_dotdot_pagectx, dest_inode, dest_dirent, Dest dest_dir, res)
                    
                | Error err ->
                    let rename_ctx = rename_ctx_t { dest_inode = Some dest_inode, src_inode, dirs }
                    and _  = ospagectx_destroy (src_dir_pagectx)
                    and _  = ospagectx_destroy (src_dotdot_pagectx)
                    and ex = destroy_Ext2DirEnt (ex, src_dotdot_dirent)
                    and ex = destroy_Ext2DirEnt (ex, src_dirent)
                    in ((ex, state, rename_ctx), Error err)
            else
                let rename_ctx = rename_ctx_t { dest_inode = Some dest_inode, src_inode, dirs }
                and _  = ospagectx_destroy (src_dir_pagectx)
                and _  = ospagectx_destroy (src_dotdot_pagectx)
                and ex = destroy_Ext2DirEnt (ex, src_dotdot_dirent)
                and ex = destroy_Ext2DirEnt (ex, src_dirent)
                in ((ex, state, rename_ctx), Error eNotEmpty)
        | Error err ->
            let rename_ctx = rename_ctx_t { dest_inode = Some dest_inode, src_inode, dirs }
            and _  = ospagectx_destroy (src_dir_pagectx)
            and _  = ospagectx_destroy (src_dotdot_pagectx)
            and ex = destroy_Ext2DirEnt (ex, src_dotdot_dirent)
            and ex = destroy_Ext2DirEnt (ex, src_dirent)

            in ((ex, state, rename_ctx), Error err)
    | _ ->
        -- no inode exists, just update the name entries
        dirs
        | SrcDest both ->
            let both_t { dest_dir } = both

            and ((ex, state, dest_dir), res) = ext2_dir_add (ex, state, dest_dir, rename_ctx_t.src_inode, rename_ctx_t.dest_name) !rename_ctx_t
            in res
            | Success () ->
                let dest_dir = vfs_inode_inc_nlink (dest_dir)

                and both = both_t { dest_dir }
                and rename_ctx = rename_ctx_t { dest_inode = None (), dirs = SrcDest both }

                in fsop_rename_remove_old_dir (ex, state, rename_ctx, src_dirent, src_dotdot_dirent, src_dir_pagectx, src_dotdot_pagectx)
            | Error err ->
                let both = both_t { dest_dir }
                and rename_ctx = rename_ctx_t { dest_inode = None (), dirs = SrcDest both }

                and _  = ospagectx_destroy (src_dir_pagectx)
                and _  = ospagectx_destroy (src_dotdot_pagectx)

                and ex = destroy_Ext2DirEnt (ex, src_dotdot_dirent)
                and ex = destroy_Ext2DirEnt (ex, src_dirent)
                in ((ex, state, rename_ctx), Error err)
        | Dest dest_dir ->
            let ((ex, state, dest_dir), res) = ext2_dir_add (ex, state, dest_dir, rename_ctx_t.src_inode, rename_ctx_t.dest_name) !rename_ctx_t
            in res
            | Success () ->
                let dest_dir = vfs_inode_inc_nlink (dest_dir)

                and rename_ctx = rename_ctx_t { dest_inode = None (), dirs = Dest dest_dir }

                in fsop_rename_remove_old_dir (ex, state, rename_ctx, src_dirent, src_dotdot_dirent, src_dir_pagectx, src_dotdot_pagectx)
            | Error (err) ->
                let rename_ctx = rename_ctx_t { dest_inode = None (), dirs = Dest dest_dir }

                and _  = ospagectx_destroy (src_dir_pagectx)
                and _  = ospagectx_destroy (src_dotdot_pagectx)

                and ex = destroy_Ext2DirEnt (ex, src_dotdot_dirent)
                and ex = destroy_Ext2DirEnt (ex, src_dirent)
                in ((ex, state, rename_ctx), Error err)

-- want to:
-- * remove pointer to src_entry from inside src_dir
-- and either:
--
-- * have a dest_entry in dest_dir, if inode exists, or
-- * have a src_inode with name dest_name in dest_dir if it doesn't.
fsop_rename: (ExState, FsState, VfsRenameContext) -> RR (ExState, FsState, VfsRenameContext) () U32
fsop_rename (ex, state, rename_ctx) =
    -- find the entry for the source in its current dir
    let ((ex, state), res) = ext2_find_entry_bang (ex, state, vfs_rename_get_src_dir (rename_ctx), rename_ctx.src_name) !rename_ctx
    in res
    | Success (src_dirent, page, pagebuf, offset) -> -- LIN: old_de, old_page
        let src_pagectx = #{ page, buf = pagebuf, pos = offset }

        and _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("fsop_rename: got page and buffers for old entry\n"))

        -- check if the source is actually a directory
        and mode = vfs_inode_get_mode (rename_ctx.src_inode) !rename_ctx
        in if vmode_is_dir(mode) then
            -- sure is! grab the parent because we need to update it too when
            -- we move the source to the destination
            let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("fsop_rename: after checking mode, source was a dir; getting parent of src dir\n"))
            in ext2_dir_get_parent (ex, state, rename_ctx.src_inode) !rename_ctx -- LIN: ext2_dotdot
            | Success (ex, state, src_dotdot_dirent, src_dotdot_pagectx) ->
                fsop_rename_dir (ex, state, rename_ctx, src_dirent, src_dotdot_dirent, src_pagectx, src_dotdot_pagectx)
            | Error (ex, state, err) ->
                -- all directories must have a parent (except root)
                let _ = _cogent_log (dbg_EXT2_DIR_WRITE, "fsop_rename: could not get parent for parent\n")

                and ex = destroy_Ext2DirEnt (ex, src_dirent)
                and _  = ospagectx_destroy (src_pagectx)

                in ((ex, state, rename_ctx), Error err)
        else
            -- we're just moving a file (ie src -> dest)
            let _ = _cogent_log (dbg_EXT2_DIR_WRITE, ("fsop_rename: after checking mode, source was not a dir\n"))
            in fsop_rename_file (ex, state, rename_ctx, src_dirent, src_pagectx)
    | Error err ->
        -- no such dirent for this given inode found
        ((ex, state, rename_ctx), Error err)
